# 2.2第二阶段-JavaScript系列-WebAPIs Dom Bom操作方法

https://www.bilibili.com/video/BV1Sy4y1C7ha

## Web APIs简介

#### 1.Web APIs和JS基础关联性

##### 1.1 JS的组成

![image-20210929122138332](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210929122138332.png)

##### 1.2 JS基础阶段以及Web APIs阶段

###### JS基础阶段

我们学习的是 ECMAscript标准规定的基本语法
要求同学们掌握Js 基础语法
只学习基本语法，做不了常用的网页交互效果
目的是为了JS后面的课程打基础、做铺垫

###### Web APIs阶段

Web APIs是w3c组织的标准
Web APIs等我们主要学习DOM和BOM
Web APIs是我们Js 所独有的部分
我们主要学习页面交互功能
需要使用JS基础的课程内容做基础

Js基础学习ECMAScript 基础语法为后面作铺垫，Web APTs 是Js的应用，大量使用Js 基础语法做交互效果。

#### 2.API和Web API

##### 2.1 API

APl ( Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。

简单理解：API是给程序员提供的一种工具，以便能更轻松的实现恕要完成的功能。

比如手机充电的接口：
我们要实现充电这个功能：
1.我们不关心手机内部变压器，内部怎么存储电等
2.我们不关心这个充电线怎么制作的
3.我们只知道，我们拿着充电线插进充电接口就可以充电
4.这个充电接口就是一个API

##### 2.2 Web API

Web API是浏览器提供的一套操作浏览器功能和页面元素的API( BOM和DOM ).现阶段我们主要针对于浏览器讲解常用的API，主要针对浏览器做交互效果。

比如我们想要浏览器弹出一个警示框，直接使用alert(‘弹出’)

MDN详细 APl：https://developer.mozilla.org/zh-CN/docs/Web/API

##### 2.3 API和 Web API总结

1.API是为我们程序员提供的一个接口，帮助我们实现某种功能，我们会使用就可以了，不必纠结内部如何实现
2.Web API主要是针对于浏览器提供的接口，主要针对于浏览器做交互效果。
3.Web API一般都有输入和输出(函数的传参和返回值)，Web API很多都是方法(函数)
4.学习Web APIl可以结合前面学习内置对象方法的思路学习

## DOM

#### 1.DOM简介

##### 1.1什么是DOM

文档对象模型(Document Object Model，简称DOM)，是W3C组织推荐的处理可扩展标记语言（HTML或者XML)的标准编程接口。

W3C已经定义了一系列的DOM接口，通过这些DOM接口可以改变网页的内容、结构和样式。

##### 1.2 DOM树

![image-20210928113452376](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210928113452376.png)

文档：一个页面就是一个文档，DOM中使用document表示。
元素：页面中的所有标签都是元素，DOM中使用element表示。
节点：网页中的所有内容都是节点(标签、属性、文本、注释等)，DOM中使用node表示。

**DOM把以上内容都看做是对象**

#### 2.获取元素

##### 2.1如何获取页面元素

DOM在我们实际开发中主要用来操作元素。
我们如何来获取页面中的元素呢？

获取页面中的元素可以使用以下几种方式：
1.根据 ID获取
2.根据标签名获取
3.通过 HTML5新增的方法获取
4.特殊元素获取

##### 2.2根据 ID获取 

使用 `getElementById()` 方法可以获取带有 ID的元素对象。

```javascript
document.getElementById('id'); 
```

使用 `console.dir()` 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。

```html
<body>
    <div id="time">2019-9-9</div>
    <script>
        // 1. 因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面
        // 2. get 获得 element 元素 by 通过 驼峰命名法 
        // 3. 参数 id是大小写敏感的字符串
        // 4. 返回的是一个元素对象
        var timer = document.getElementById('time');
        console.log(timer);
        console.log(typeof timer);
        // 5. console.dir 打印我们返回的元素对象 更好的查看里面的属性和方法
        console.dir(timer);
    </script>
</body>
```

##### 2.3根据标签名获取

使用 `getElementsByTagName()` 方法可以返回带有指定标签名的对象的集合。 

```javascript
document.getElementsByTagName('标签名'); 
```

注意：
1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。
2.得到元素对象是动态的。

```html
<body>
    <ul>
        <li>知否知否，应是等你好久11</li>
        <li>知否知否，应是等你好久11</li>
        <li>知否知否，应是等你好久11</li>
        <li>知否知否，应是等你好久11</li>
    </ul>
    <ol id="ol">
        <li>生僻字</li>
        <li>生僻字</li>
        <li>生僻字</li>
        <li>生僻字</li>
    </ol>

    <script>
        // 1. 返回的是 获取过来元素对象的集合 以伪数组的形式存储的
        var lis = document.getElementsByTagName('li');
        console.log(lis);
        console.log(lis[0]);
        // 2. 我们想要依次打印里面的元素对象我们可以采取遍历的方式
        for (var i = 0; i < lis.length; i++) {
            console.log(lis[i]);
        }
        // 3. 如果页面中只有一个li 返回的还是伪数组的形式 
        // 4. 如果页面中没有这个元素 返回的是空的伪数组的形式
        // 5. element.getElementsByTagName('标签名'); 父元素必须是指定的单个元素
        // var ol = document.getElementsByTagName('ol'); // [ol] 会报错
        // console.log(ol[0].getElementsByTagName('li')); //不会报错，但是比较麻烦
        var ol = document.getElementById('ol');
        console.log(ol.getElementsByTagName('li'));
    </script>
</body>
```

##### 2.4通过 HTML5新增的方法获取  

```
1.document.getElementsByClassName('类名');  // 根据类名返回元素对象集合
```

```
2.document.querySelector('选择器');  // 根据指定选择器返回第一个元素对象
```

```
3.document.querySelectorAll('选择器');  // 根据指定选择器返回
```

注意：
`querySelector` 和 `querySelectorAll` 里面的选择器需要加符号，比如：`document.querySelector('#nav');`

```html
<body>
    <div class="box">盒子1</div>
    <div class="box">盒子2</div>
    <div id="nav">
        <ul>
            <li>首页</li>
            <li>产品</li>
        </ul>
    </div>
    <script>
        // 1. getElementsByClassName 根据类名获得某些元素集合
        var boxs = document.getElementsByClassName('box');
        console.log(boxs);
        // 2. querySelector 返回指定选择器的第一个元素对象  切记 里面的选择器需要加符号 .box  #nav
        var firstBox = document.querySelector('.box');
        console.log(firstBox);
        var nav = document.querySelector('#nav');
        console.log(nav);
        var li = document.querySelector('li');
        console.log(li);
        // 3. querySelectorAll()返回指定选择器的所有元素对象集合
        var allBox = document.querySelectorAll('.box');
        console.log(allBox);
        var lis = document.querySelectorAll('li');
        console.log(lis);
    </script>
</body>
```

##### 2.5获取特殊元素（body,html） 

获取body元素

```
1.doucumnet.body  // 返回body元素对象 
```

获取html元素

```
2.document.documentElement  // 返回html元素对象
```

```html
<body>
    <script>
        // 1.获取body 元素
        var bodyEle = document.body;
        console.log(bodyEle);
        console.dir(bodyEle);
        // 2.获取html 元素
        // var htmlEle = document.html;
        var htmlEle = document.documentElement;
        console.log(htmlEle);
    </script>
</body>
```

#### 3.事件基础

##### 3.1事件概述

JavaScript使我们有能力创建动态页面，而事件是可以被 JavaScript侦测到的行为。

简单理解：触发---响应机制。

网页中的每个元素都可以产生某些可以触发 JavaScript的事件，例如，我们可以在用户点击某按钮时产生一个事件，然后去执行某些操作。

##### 3.2事件三要素

1.事件源（谁）
2.事件类型（什么事件）
3.事件处理程序（做啥）

##### 3.3执行事件的步骤

1.获取事件源
2.注册事件（绑定事件）
3.添加事件处理程序（采取函数赋值形式）

##### 3.3常见的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左健触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

##### 3.4分析事件三要素

下拉菜单三要素 / 关闭广告三要素

#### 4.操作元素

JavaScript的 DOM操作可以改变网页内容、结构和样式，我们可以利用 DOM操作元素来改变元素里面的内容、属性等。

注意以下都是属性：

##### 4.1改变元素内容 

```
element.innerText
```

从起始位置到终止位置的内容,但它去除 html标签，同时空格和换行也会去掉 

```
element.innerHTML
```

起始位置到终止位置的全部内容，包括 html标签，同时保留空格和换行

```html
<body>
    <button>显示当前系统时间</button>
    <div>某个时间</div>
    <p>1123</p>
    <script>
        // 当我们点击了按钮，  div里面的文字会发生变化
        // 1. 获取元素 
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        // 2.注册事件
        btn.onclick = function() {
            // div.innerText = '2019-6-6';
            div.innerHTML = getDate();
        }

        function getDate() {  // 封装了之前的函数
            var date = new Date();
            // 我们写一个 2019年 5月 1日 星期三
            var year = date.getFullYear();
            var month = date.getMonth() + 1;
            var dates = date.getDate();
            var arr = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            var day = date.getDay();
            return '今天是：' + year + '年' + month + '月' + dates + '日 ' + arr[day];
        }
        // 我们元素可以不用添加事件
        var p = document.querySelector('p');
        p.innerHTML = getDate();
    </script>
</body>
```

###### innerText 和 innerHTML的区别

```html
<body>
    <div></div>
    <p>
        我是文字
        <span>123</span>
    </p>
    <script>
        // innerText 和 innerHTML的区别 
        // 1. innerText 不识别html标签 非标准  去除空格和换行
        var div = document.querySelector('div');
        // div.innerText = '<strong>今天是：</strong> 2019';
        // 2. innerHTML 识别html标签 W3C标准 保留空格和换行的
        div.innerHTML = '<strong>今天是：</strong> 2019';
        // 这两个属性是可读写的  可以获取元素里面的内容
        var p = document.querySelector('p');
        console.log(p.innerText);
        console.log(p.innerHTML);
    </script>
</body>
```

##### 4.2常用元素的属性操作 

```
1. innerText、innerHTML改变元素内容
2. src、href
3. id、alt、title
```

```html
<body>
    <button id="ldh">刘德华</button>
    <button id="zxy">张学友</button> <br>
    <img src="images/ldh.jpg" alt="" title="刘德华">

    <script>
        // 修改元素属性  src
        // 1. 获取元素
        var ldh = document.getElementById('ldh');
        var zxy = document.getElementById('zxy');
        var img = document.querySelector('img');
        // 2. 注册事件  处理程序
        zxy.onclick = function() {
            img.src = 'images/zxy.jpg';
            img.title = '张学友思密达';
        }
        ldh.onclick = function() {
            img.src = 'images/ldh.jpg';
            img.title = '刘德华';
        }
    </script>
</body>
```

###### 案例：分时显示不同图片,显示不同问候语

根据不同时间，页面显示不同图片，同时显示不同的问候语。
如果上午时间打开页面，显示上午好，显示上午的图片。
如果下午时间打开页面，显示下午好，显示下午的图片。
如果晚上时间打开页面，显示晚上好，显示晚上的图片。

###### 案例分析

1.根据系统不同时间来判断，所以需要用到日期内置对象。
2.利用多分支语句来设置不同的图片。
3.需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性。
4.需要一个div元素，显示不同问候语，修改元素内容即可。

```html
<body>
    <img src="images/s.gif" alt="">
    <div>上午好</div>
    <script>
        // 根据系统不同时间来判断，所以需要用到日期内置对象
        // 利用多分支语句来设置不同的图片
        // 需要一个图片，并且根据时间修改图片，就需要用到操作元素src属性
        // 需要一个div元素，显示不同问候语，修改元素内容即可
        // 1.获取元素
        var img = document.querySelector('img');
        var div = document.querySelector('div');
        // 2. 得到当前的小时数
        var date = new Date();
        var h = date.getHours();
        // 3. 判断小时数改变图片和文字信息
        if (h < 12) {
            img.src = 'images/s.gif';
            div.innerHTML = '亲，上午好，好好写代码';
        } else if (h < 18) {
            img.src = 'images/x.gif';
            div.innerHTML = '亲，下午好，好好写代码';
        } else {
            img.src = 'images/w.gif';
            div.innerHTML = '亲，晚上好，好好写代码';
        }
    </script>
</body>
```

##### 4.3表单元素的属性操作

利用 DOM可以操作如下表单元素的属性： 

```
type、value、checked、selected、disabled
```

```html
<body>
    <button>按钮</button>
    <input type="text" value="输入内容">
    <script>
        // 1. 获取元素
        var btn = document.querySelector('button');
        var input = document.querySelector('input');
        // 2. 注册事件 处理程序
        btn.onclick = function() {
            // input.innerHTML = '点击了';  这个是 普通盒子 比如 div 标签里面的内容
            // 表单里面的值 文字内容是通过 value 来修改的
            input.value = '被点击了';
            // 如果想要某个表单被禁用 不能再点击 disabled  我们想要这个按钮 button禁用
            // btn.disabled = true;
            this.disabled = true;
            // this 指向的是事件函数的调用者 btn
        }
    </script>
</body>
```

###### 案例：仿京东显示密码

###### 案例分析

1.核心思路：点击眼睛按钮，把密码框类型改为文本框就可以看见里面的密码
2.一个按钮两个状态，点击一次，切换为文本框，继续点击一次切换为密码框
3.算法：利用一个flag变量，来判断flag的值，如果是1就切换为文本框，flag设置为0，如
果是0就切换为密码框，flag设置为1。

```html
<body>
    <div class="box">
        <label for="">
            <img src="images/close.png" alt="" id="eye">
        </label>
        <input type="password" name="" id="pwd">
    </div>
    <script>
        // 1. 获取元素
        var eye = document.getElementById('eye');
        var pwd = document.getElementById('pwd');
        // 2. 注册事件 处理程序
        var flag = 0;
        eye.onclick = function () {
            // 点击一次之后， flag 一定要变化
            if (flag == 0) {
                pwd.type = 'text';
                eye.src = 'images/open.png';
                flag = 1; // 赋值操作
            } else {
                pwd.type = 'password';
                eye.src = 'images/close.png';
                flag = 0;
            }
        }
    </script>
</body>
```

##### 4.4样式属性操作

我们可以通过 JS修改元素的大小、颜色、位置等样式。

```
element.style		行内样式操作 
element.className	类名样式操作
```


```html
// element.style 行内样式操作 
<body>
    <div style=" width: 200px;
    height: 200px;
    background-color: pink;"></div>
    <script>
        // 1. 获取元素
        var div = document.querySelector('div');
        // 2. 注册事件 处理程序
        div.onclick = function () {
            // div.style里面的属性 采取驼峰命名法 
            this.style.backgroundColor = 'purple';
            this.style.width = '250px';
        }
    </script>
</body>
```

注意：
1.JS里面的样式采取驼峰命名法比如 `fontSize`、`backgroundColor` 。
2.JS修改style样式操作，产生的是行内样式，CSS权重比较高。

```html
// element.className  类名样式操作
<style>
	div {
		width: 100px;
		height: 100px;
		background-color: pink;
	}

	.change {
		background-color: purple;
		color: #fff;
		font-size: 25px;
		margin-top: 100px;
	}
</style>

<body>
	<div class="first">文本</div>
	<script>
		// 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用
		var test = document.querySelector('div');
		test.onclick = function () {
			// this.style.backgroundColor = 'purple';
			// this.style.color = '#fff';
			// this.style.fontSize = '25px';
			// this.style.marginTop = '100px';
			// 让我们当前元素的类名改为了 change

			// 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况
			// 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器
			// this.className = 'change';
			this.className = 'first change';
		}
	</script>
</body>
```

注意：
1.如果样式修改较多，可以采取操作类名方式更改元素样式。 
2.class因为是个保留字，因此使用 className来操作元素类名属性。
3.className会直接更改元素的类名，会覆盖原先的类名。

###### 案例：淘宝点击关闭二维码

###### 案例分析

1.核心思路：利用样式的显示和隐藏完成，`display:none` 隐藏元素 / `display:block` 显示元素。
2.点击按钮，就让这个二维码盒子隐藏起来即可。

```html
<body>
    <div class="box">
        淘宝二维码
        <img src="images/tao.png" alt="">
        <i class="close-btn">×</i>
    </div>
    <script>
        // 1. 获取元素 
        var btn = document.querySelector('.close-btn');
        var box = document.querySelector('.box');
        // 2.注册事件 程序处理
        btn.onclick = function() {
            box.style.display = 'none';
        }
    </script>
</body>
```

###### 案例：循环精灵图背景

可以利用for循环设置一组元素的精灵图背景

###### 案例分析

1.首先精灵图图片排列有规律的
2.核心思路：利用for循环，修改精灵图片的背景位置background-position
3.剩下的就是考验你的数学功底了
4.让循环里面的i索引号*44就是每个图片的y坐标

```html
<script>
	// 1. 获取元素 所有的小 li 
	var lis = document.querySelectorAll('li');
	for (var i = 0; i < lis.length; i++) {
		// 让索引号 乘以 44 就是每个li 的背景y坐标  index就是我们的y坐标
		var index = i * 44;
		lis[i].style.backgroundPosition = '0 -' + index + 'px';
	}
</script>
```

###### 案例：显示隐藏文本框内容

当鼠标点击文本框时，里面的默认文字隐藏，当鼠标离开文本框时，里面的文字显示。

###### 案例分析

1.首先表单需要2个新事件，获得焦点 `onfocus` 失去焦点 `onblur`
2.如果获得焦点，判断表单里面内容是否为默认文字，如果是默认文字，就清空表单内容3.如果失去焦点，判断表单内容是否为空，如果为空，则表单内容改为默认文字

```html
<body>
	<input type="text" value="手机">
	<script>
	// 1.获取元素
	var text = document.querySelector('input');
	// 2.注册事件 获得焦点事件 onfocus 
	text.onfocus = function () {
		// console.log('得到了焦点');
		if (this.value === '手机') {
			this.value = '';
		}
		// 获得焦点需要把文本框里面的文字颜色变黑
		this.style.color = '#333';
	}
	// 3. 注册事件 失去焦点事件 onblur
	text.onblur = function () {
		// console.log('失去了焦点');
		if (this.value === '') {
			this.value = '手机';
		}
		// 失去焦点需要把文本框里面的文字颜色变浅色
		this.style.color = '#999';
	}
	</script>
</body>
```

###### 案例：密码框格式提示错误信息

用户如果离开密码框，里面输入个数不是6~16，则提示错误信息，否则提示输入正确信息。

###### 案例分析

1.首先判断的事件是表单失去焦点onblur。
2.如果输入正确则提示正确的信息颜色为绿色小图标变化。
3.如果输入不是6到16位，则提示错误信息颜色为红色小图标变化。
4.因为里面变化样式较多，我们采取className修改样式。

```html
<body>
    <div class="register">
        <input type="password" class="ipt">
        <p class="message">请输入6~16位密码</p>
    </div>
    <script>
        // 首先判断的事件是表单失去焦点 onblur
        // 如果输入正确则提示正确的信息颜色为绿色小图标变化
        // 如果输入不是6到16位，则提示错误信息颜色为红色 小图标变化
        // 因为里面变化样式较多，我们采取className修改样式
        // 1.获取元素
        var ipt = document.querySelector('.ipt');
        var message = document.querySelector('.message');
        //2. 注册事件 失去焦点
        ipt.onblur = function () {
            // 根据表单里面值的长度 ipt.value.length
            if (this.value.length < 6 || this.value.length > 16) {
                // console.log('错误');
                message.className = 'message wrong';
                message.innerHTML = '您输入的位数不对要求6~16位';
            } else {
                message.className = 'message right';
                message.innerHTML = '您输入的正确';
            }
        }
    </script>
</body>
```

##### 操作元素总结

操作元素是DOM核心内容

![image-20210930133011405](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20210930133011405.png)

###### 开关灯案例

```html
<body>
	<button id="btn">开关灯</button>
	<script>
		var btn = document.getElementById('btn');
		var flag = 0;
		btn.onclick = function() {
			if (flag == 0) {
				document.body.style.backgroundColor = '#000';
				flag = 1;
			} else {
				document.body.style.backgroundColor = '#fff';
				flag = 0;
			}
		}
	</script>
</body>
```

##### 4.5排他思想

如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：
1.所有元素全部清除样式（干掉其他人）
2.给当前元素设置样式（留下我自己）
3.注意顺序不能颠倒，首先干掉其他人，再设置自己。

```html
<body>
	<button>按钮1</button>
	<button>按钮2</button>
	<button>按钮3</button>
	<button>按钮4</button>
	<button>按钮5</button>
	<script>
		// 1. 获取所有按钮元素
		var btns = document.getElementsByTagName('button');
		// btns得到的是伪数组  里面的每一个元素 btns[i]
		for (var i = 0; i < btns.length; i++) {
			btns[i].onclick = function() {
				// (1) 我们先把所有的按钮背景颜色去掉  干掉所有人
				for (var i = 0; i < btns.length; i++) {
					btns[i].style.backgroundColor = '';
				}
				// (2) 然后才让当前的元素背景颜色为pink 留下我自己
				this.style.backgroundColor = 'pink';
			}
		}
		// 2. 首先先排除其他人，然后才设置自己的样式 这种排除其他人的思想我们成为排他思想
	</script>
</body>
```

###### 案例：百度换肤

###### 案例分析

1.这个案例练习的是给一组元素注册事件。
2.给4个小图片利用循环注册点击事件。
3.当我们点击了这个图片，让我们页面背景改为当前的图片。
4.核心算法：把当前图片的src路径取过来，给body 做为背景即可。

```html
<body>
	<ul class="baidu">
		<li><img src="images/1.jpg"></li>
		<li><img src="images/2.jpg"></li>
		<li><img src="images/3.jpg"></li>
		<li><img src="images/4.jpg"></li>
	</ul>
	<script>
		// 1. 获取元素 
		var imgs = document.querySelector('.baidu').querySelectorAll('img');
		// console.log(imgs);
		// 2. 循环注册事件 
		for (var i = 0; i < imgs.length; i++) {
			imgs[i].onclick = function() {
				// this.src 就是我们点击图片的路径   images/2.jpg
				// console.log(this.src);
				// 把这个路径 this.src 给body 就可以了
				document.body.style.backgroundImage = 'url(' + this.src + ')';
			}
		}
	</script>
</body>
```

###### 案例：表格隔行变色

###### 案例分析

1.用到新的鼠标事件，鼠标经过onmouseover，鼠标离开onmouseout。
2.核心思路：鼠标经过tr行，当前的行变背景颜色，鼠标离开去掉当前的背景颜色。
3.注意：第一行(thead里面的行）不需要变换颜色，因此我们获取的是tbody里面的行。

```html
<style>
	table {
		width: 800px;
		margin: 100px auto;
		text-align: center;
		border-collapse: collapse;
		font-size: 14px;
	}

	thead tr {
		height: 30px;
		background-color: skyblue;
	}

	tbody tr {
		height: 30px;
	}

	tbody td {
		border-bottom: 1px solid #d7d7d7;
		font-size: 12px;
		color: blue;
	}

	.bg {
		background-color: pink;
	}
</style>

<body>
    <table>
        <thead>
            <tr>
                <th>代码</th>
                <th>名称</th>
                <th>最新公布净值</th>
                <th>累计净值</th>
                <th>前单位净值</th>
                <th>净值增长率</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
            <tr>
                <td>003526</td>
                <td>农银金穗3个月定期开放债券</td>
                <td>1.075</td>
                <td>1.079</td>
                <td>1.074</td>
                <td>+0.047%</td>
            </tr>
        </tbody>
    </table>
    <script>
        // 1.获取元素 获取的是 tbody 里面所有的行
        var trs = document.querySelector('tbody').querySelectorAll('tr');
        // 2. 利用循环绑定注册事件
        for (var i = 0; i < trs.length; i++) {
            // 3. 鼠标经过事件 onmouseover
            trs[i].onmouseover = function () {
                // console.log(11);
                this.className = 'bg';
            }
            // 4. 鼠标离开事件 onmouseout
            trs[i].onmouseout = function () {
                this.className = '';
            }
        }
    </script>
</body>
```

###### 案例：表单全选取消全选案例

业务需求：
1.点击上面全选复选框，下面所有的复选框都选中(全选)
2.再次点击全选复选框，下面所有的复选框都不中选(取消全选)
3．如果下面复选框全部选中，上面全选按钮就自动选中
4.如果下面复选框有一个没有选中，上面全选按钮就不选中
5.所有复选框—开始默认都没选中状态

###### 案例分析

1.全选和取消全选做法：让下面所有复选框的checked属性(选中状态)跟随全选按钮即可。
2.下面复选框需要全部选中，上面全选才能选中做法:给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的，上面全选就不选中。
3.可以设置一个变量，来控制全选是否选中。

```html
<body>
    <div class="wrap">
        <table>
            <thead>
                <tr>
                    <th>
                        <input type="checkbox" id="j_cbAll" />
                    </th>
                    <th>商品</th>
                    <th>价钱</th>
                </tr>
            </thead>
            <tbody id="j_tb">
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPhone8</td>
                    <td>8000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPad Pro</td>
                    <td>5000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>iPad Air</td>
                    <td>2000</td>
                </tr>
                <tr>
                    <td>
                        <input type="checkbox" />
                    </td>
                    <td>Apple Watch</td>
                    <td>2000</td>
                </tr>

            </tbody>
        </table>
    </div>
    <script>
        // 1. 全选和取消全选做法：  让下面所有复选框的checked属性（选中状态） 跟随 全选按钮即可
        // 获取元素
        var j_cbAll = document.getElementById('j_cbAll'); // 全选按钮
        var j_tbs = document.getElementById('j_tb').getElementsByTagName('input'); // 下面所有的复选框
        // 注册事件
        j_cbAll.onclick = function () {
            // this.checked 它可以得到当前复选框的选中状态如果是true 就是选中，如果是false 就是未选中
            console.log(this.checked);
            for (var i = 0; i < j_tbs.length; i++) {
                j_tbs[i].checked = this.checked;
            }
        }
        // 2. 下面复选框需要全部选中， 上面全选才能选中做法： 给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的， 上面全选就不选中。
        for (var i = 0; i < j_tbs.length; i++) {
            j_tbs[i].onclick = function () {
                // flag 控制全选按钮是否选中
                var flag = true;
                // 每次点击下面的复选框都要循环检查者4个小按钮是否全被选中
                for (var i = 0; i < j_tbs.length; i++) {
                    if (!j_tbs[i].checked) {
                        flag = false;
                        break; // 退出for循环 这样可以提高执行效率 因为只要有一个没有选中，剩下的就无需循环判断了
                    }
                }
                j_cbAll.checked = flag;
            }
        }
    </script>
</body>
```

##### 4.6自定义属性的操作

###### 1.获取属性值 element.getAttribute

```javascript
element.属性  // 获取属性值 
element.getAttribute('属性');

区别： 
element.属性  // 获取内置属性值（元素本身自带的属性） 
element.getAttribute('属性');  // 主要获得自定义的属性（标准）我们程序员自定义的属性
```

###### 2.设置属性值 element.setAttribute

```javascript
element.属性 ='值'  // 设置内置属性值 
element.setAttribute('属性', '值');

区别： 
element.属性  // 设置内置属性值 
element.setAttribute('属性');  // 主要设置自定义的属性（标准）
```

###### 3.移除属性 element.removeAttribute

```javascript
element.removeAttribute('属性');
```

```html
<body>
    <div id="demo" index="1" class="nav"></div>
    <script>
        var div = document.querySelector('div');
        // 1. 获取元素的属性值
        // (1) element.属性
        console.log(div.id);
        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index
        console.log(div.getAttribute('id'));
        console.log(div.getAttribute('index'));
        // 2. 设置元素属性值
        // (1) element.属性= '值'
        div.id = 'test';
        div.className = 'navs';
        // (2) element.setAttribute('属性', '值');  主要针对于自定义属性
        div.setAttribute('index', 2);
        div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是class 不是className
        // 3 移除属性 removeAttribute(属性)    
        div.removeAttribute('index');
    </script>
</body>
```

###### 案例：tab栏切换（重点案例）

当鼠标点击上面相应的选项卡(tab)，下面内容跟随切换。

###### 案例分析

1.Tab栏切换有2个大的模块。
2.上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变(排他思想）修改类
名的方式。
3.下面的模块内容，会跟随上面的选项卡变化。所以下面模块变化写到点击事件里面。
4.规律：下面的模块显示内容和上面的选项卡——对应，相匹配。
5.核心思路：给上面的tab_list里面的所有小li添加自定义属性．属性值从0开始编号。
6.当我们点击tab_list 里面的某个小li. 让tab_con里面对应序号的内容显示．其余隐藏(00排他思想)。

```html
<style>
	* {
	    margin: 0;
	    padding: 0;
	}

	li {
	    list-style-type: none;
	}

	.tab {
	    width: 978px;
	    margin: 100px auto;
	}

	.tab_list {
	    height: 39px;
	    border: 1px solid #ccc;
	    background-color: #f1f1f1;
	}

	.tab_list li {
	    float: left;
	    height: 39px;
	    line-height: 39px;
	    padding: 0 20px;
	    text-align: center;
	    cursor: pointer;
	}

	.tab_list .current {
	    background-color: #c81623;
	    color: #fff;
	}

	.item_info {
	    padding: 20px 0 0 20px;
	}

	.item {
	    display: none;
	}
</style>

<body>
    <div class="tab">
        <div class="tab_list">
            <ul>
                <li class="current">商品介绍</li>
                <li>规格与包装</li>
                <li>售后保障</li>
                <li>商品评价（50000）</li>
                <li>手机社区</li>
            </ul>
        </div>
        <div class="tab_con">
            <div class="item" style="display: block;">商品介绍模块内容</div>
            <div class="item">规格与包装模块内容</div>
            <div class="item">售后保障模块内容</div>
            <div class="item">商品评价（50000）模块内容</div>
            <div class="item">手机社区模块内容</div>
        </div>
    </div>
    <script>
        // 获取元素
        var tab_list = document.querySelector('.tab_list');
        var lis = tab_list.querySelectorAll('li');
        var items = document.querySelectorAll('.item');
        // for循环绑定点击事件
        for (var i = 0; i < lis.length; i++) {
            // 开始给5个小li 设置索引号 
            lis[i].setAttribute('index', i);
            lis[i].onclick = function () {
                // 1. 上的模块选项卡，点击某一个，当前这一个底色会是红色，其余不变（排他思想） 修改类名的方式
                // 干掉所有人 其余的li清除 class 这个类
                for (var i = 0; i < lis.length; i++) {
                    lis[i].className = '';
                }
                // 留下我自己 
                this.className = 'current';
                // 2. 下面的显示内容模块
                var index = this.getAttribute('index');
                console.log(index);
                // 干掉所有人 让其余的item 这些div 隐藏
                for (var i = 0; i < items.length; i++) {
                    items[i].style.display = 'none';
                }
                // 留下我自己 让对应的item 显示出来
                items[index].style.display = 'block';
            }
        }
    </script>
</body>
```

##### 4.7 H5自定义属性

自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。
自定义属性获取是通过 getAttribute(‘属性’)获取。
但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。 

H5给我们新增了自定义属性：

###### 1.设置H5自定义属性

H5规定自定义属性 data- 开头做为属性名并且赋值。

比如：

```html
<div data-index="1"></div>
```

或者使用 JS设置： 

```javascript
element.setAttribute('data-index’, 2) 
```

###### 2.获取H5自定义属性 

1.兼容性获取：

```javascript
element.getAttribute(‘data-index’); 
```

2.H5新增：

```javascript
element.dataset.index
// 或者
element.dataset['index']  // ie 11才开始支持
```

```html
<body>
	<div getTime="20" data-index="2" data-list-name="andy"></div>
	<script>
		var div = document.querySelector('div');
		// console.log(div.getTime);
		console.log(div.getAttribute('getTime'));
		div.setAttribute('data-time', 20);
		console.log(div.getAttribute('data-index'));
		console.log(div.getAttribute('data-list-name'));
		// h5新增的获取自定义属性的方法 它只能获取data-开头的
		// dataset 是一个集合里面存放了所有以data开头的自定义属性
		console.log(div.dataset);
		console.log(div.dataset.index);
		console.log(div.dataset['index']);
		// 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法
		console.log(div.dataset.listName);
		console.log(div.dataset['listName']);
	</script>
</body>
```

#### 5.节点操作

##### 5.1为什么学节点操作

获取元素通常使用两种方式：

###### 1.利用 DOM提供的方法获取元素

document.getElementById()
document.getElementsByTagName()
document.querySelector等
逻辑性不强、繁琐 

###### 2.利用节点层级关系获取元素 

利用父子兄节点关系获取元素 
逻辑性强，但是兼容性稍差

这两种方式都可以获取元素节点，我们后面都会使用，但是节点操作更简单。

##### 5.2节点概述

网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM中，节点使用 node来表示。
HTML DOM树中的所有节点均可通过 JavaScript进行访问，所有 HTML元素（节点）均可被修改，也可以创建或删除。

一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。

元素节点 nodeType为 1
属性节点 nodeType为 2
文本节点 nodeType为 3（文本节点包含文字、空格、换行等）

我们在实际开发中，节点操作主要操作的是元素节点。

##### 5.3节点层级

利用 DOM树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。

###### 1.父级节点 

```javascript
node.parentNode
```

parentNode属性可返回某节点的父节点，注意是最近的一个父节点 
如果指定的节点没有父节点则返回 null

```html
<script>
	// 1. 父节点 parentNode
	var erweima = document.querySelector('.erweima');
	// var box = document.querySelector('.box');
	// 得到的是离元素最近的父级节点(亲爸爸) 如果找不到父节点就返回为 null
	console.log(erweima.parentNode);
</script>
```

###### 2.子节点 

```
1.parentNode.childNodes（标准） 
```

parentNode.childNodes返回包含指定节点的子节点的集合，该集合为即时更新的集合。

注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。

如果只想要获得里面的元素节点，则需要专门处理。所以我们一般不提倡使用childNodes 

```javascript
var ul = document.querySelector('ul');
for (var i = 0; i < ul.childNodes.length; i++) {
	if (ul.childNodes[i].nodeType == 1) {
		// ul.childNodes[i] 是元素节点  
		console.log(ul.childNodes[i]);
	}
}
```

```
2.parentNode.children（非标准） 
```

parentNode.children是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回（这个是我们重点掌握的）。

虽然children是一个非标准，但是得到了各个浏览器的支持，因此我们可以放心使用。

```html
<script>
	// DOM 提供的方法（API）获取
	var ul = document.querySelector('ul');
	var lis = ul.querySelectorAll('li');
	// 1. 子节点  childNodes 所有的子节点 包含 元素节点 文本节点等等
	console.log(ul.childNodes);
	console.log(ul.childNodes[0].nodeType);
	console.log(ul.childNodes[1].nodeType);
	// 2. children 获取所有的子元素节点 也是我们实际开发常用的
	console.log(ul.children);
</script>
```

```
3.parentNode.firstChild
```

firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。 

```
4.parentNode.lastChild
```

lastChild返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。

```
5.parentNode.firstElementChild 
```

firstElementChild返回第一个子元素节点，找不到则返回null。 

```
6.parentNode.lastElementChild 
```

lastElementChild返回最后一个子元素节点，找不到则返回null。

注意：5.6这两个方法有兼容性问题， IE9以上才支持。

实际开发中， firstChild和 lastChild包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？

解决方案：
1.如果想要第一个子元素节点，可以使用 `parentNode.chilren[0]`
2.如果想要最后一个子元素节点，可以使用  `parentNode.chilren[parentNode.chilren.length - 1]`

```html
<script>
	var ol = document.querySelector('ol');
	// 1. firstChild 第一个子节点 不管是文本节点还是元素节点
	console.log(ol.firstChild);
	console.log(ol.lastChild);
	// 2. firstElementChild 返回第一个子元素节点 ie9才支持
	console.log(ol.firstElementChild);
	console.log(ol.lastElementChild);
	// 3. 实际开发的写法  既没有兼容性问题又返回第一个子元素
	console.log(ol.children[0]);
	console.log(ol.children[ol.children.length - 1]);
</script>
```

###### 案例：下拉案例

###### 案例分析

1.导航栏里面的li都要有鼠标经过效果，所以需要循环注册鼠标事件。
2.核心原理：当鼠标经过li里面的第二个孩子ul显示，当鼠标离开，则ul隐藏。

```html
<style>
	* {
	    margin: 0;
	    padding: 0;
	}
	
	li {
	    list-style-type: none;
	}
	
	a {
	    text-decoration: none;
	    font-size: 14px;
	}
	
	.nav {
	    margin: 100px;
	}
	
	.nav>li {
	    position: relative;
	    float: left;
	    width: 80px;
	    height: 41px;
	    text-align: center;
	}
	
	.nav li a {
	    display: block;
	    width: 100%;
	    height: 100%;
	    line-height: 41px;
	    color: #333;
	}
	
	.nav>li>a:hover {
	    background-color: #eee;
	}
	
	.nav ul {
	    display: none;
	    position: absolute;
	    top: 41px;
	    left: 0;
	    width: 100%;
	    border-left: 1px solid #FECC5B;
	    border-right: 1px solid #FECC5B;
	}
	
	.nav ul li {
	    border-bottom: 1px solid #FECC5B;
	}
	
	.nav ul li a:hover {
	    background-color: #FFF5DA;
	}
</style>

<body>
    <ul class="nav">
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
        <li>
            <a href="#">微博</a>
            <ul>
                <li>
                    <a href="">私信</a>
                </li>
                <li>
                    <a href="">评论</a>
                </li>
                <li>
                    <a href="">@我</a>
                </li>
            </ul>
        </li>
    </ul>
    <script>
        // 1. 获取元素
        var nav = document.querySelector('.nav');
        var lis = nav.children; // 得到4个小li
        // 2.循环注册事件
        for (var i = 0; i < lis.length; i++) {
            lis[i].onmouseover = function () {
                this.children[1].style.display = 'block';
            }
            lis[i].onmouseout = function () {
                this.children[1].style.display = 'none';
            }
        }
    </script>
</body>
```

###### 3.兄弟节点

```
1.node.nextSibling 
```

nextSibling返回当前元素的下一个兄弟元素节点，找不到则返回 null。同样，也是包含所有的节点。 

```
2.node.previousSibling 
```

previousSibling返回当前元素上一个兄弟元素节点，找不到则返回 null。同样，也是包含所有的节点。

```
3.node.nextElementSibling 
```

nextElementSibling返回当前元素下一个兄弟元素节点，找不到则返回null。 

```
4.node.previousElementSibling 
```

previousElementSibling返回当前元素上一个兄弟节点，找不到则返回null。

注意：3.4这两个方法有兼容性问题， IE9以上才支持。

```html
<body>
	<div>我是div</div>
	<span>我是span</span>
	<script>
		var div = document.querySelector('div');
		// 1. nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等
		console.log(div.nextSibling);
		console.log(div.previousSibling);
		// 2. nextElementSibling 得到下一个兄弟元素节点
		console.log(div.nextElementSibling);
		console.log(div.previousElementSibling);
	</script>
</body>
```

问：如何解决兼容性问题？
答：自己封装一个兼容性的函数。

```javascript
function getNextElementsibling(element) {
	var el = element;
	while (el = el.nextSibling) {
		if (el.nodeType === 1) {
			return el;
		}
	}
	return null;
}
```

##### 5.4创建节点

```javascript
document.createElement('tagName') 
```

`document.createElement()` 方法创建由 tagName指定的 HTML元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为动态创建元素节点。

##### 5.4添加节点

```javascript
1.node.appendChild(child) 
```

node.appendChild()方法将一个节点添加到指定父节点的子节点列表末尾。类似于 CSS里面的 after伪元素。

```
2.node.insertBefore(child,指定元素 ) 
```

node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面。类似于 CSS里面的 before伪元素。

```html
<body>
	<ul>
		<li>123</li>
	</ul>
	<script>
		// 1. 创建节点元素节点
		var li = document.createElement('li');
		// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push
		var ul = document.querySelector('ul');
		ul.appendChild(li);
		// 3. 添加节点 node.insertBefore(child, 指定元素);
		var lili = document.createElement('li');
		ul.insertBefore(lili, ul.children[0]);
		// 4. 我们想要页面添加一个新的元素 ： 1. 创建元素 2. 添加元素
	</script>
</body>
```

###### 案例：简单版发布留言案例

###### 案例分析

1.核心思路：点击按钮之后，就动态创建一个li，添加到ul里面。
2.创建li的同时，把文本域里面的值通过li.innerHTML赋值给li。
3.如果想要新的留言后面显示就用appendChild 如果想要前面显示就用insertBefore。

```html
<body>
	<textarea name="" id=""></textarea>
	<button>发布</button>
	<ul>

	</ul>
	<script>
		// 1. 获取元素
		var btn = document.querySelector('button');
		var text = document.querySelector('textarea');
		var ul = document.querySelector('ul');
		// 2. 注册事件
		btn.onclick = function () {
			if (text.value == '') {
				alert('您没有输入内容');
				return false;
			} else {
				// console.log(text.value);
				// (1) 创建元素
				var li = document.createElement('li');
				// 先有li 才能赋值
				li.innerHTML = text.value;
				// (2) 添加元素
				// ul.appendChild(li);
				ul.insertBefore(li, ul.children[0]);
			}
		}
	</script>
</body>
```

##### 5.5删除节点

```javascript
node.removeChild(child) 
```

node.removeChild()方法从 DOM中删除一个子节点，返回删除的节点。

```html
<body>
	<button>删除</button>
	<ul>
		<li>熊大</li>
		<li>熊二</li>
		<li>光头强</li>
	</ul>
	<script>
		// 1.获取元素
		var ul = document.querySelector('ul');
		var btn = document.querySelector('button');
		// 2. 删除元素  node.removeChild(child)
		// ul.removeChild(ul.children[0]);
		// 3. 点击按钮依次删除里面的孩子
		btn.onclick = function () {
			if (ul.children.length == 0) {
				this.disabled = true;
			} else {
				ul.removeChild(ul.children[0]);
			}
		}
	</script>
</body>
```

###### 案例：删除留言案例

###### 案例分析

1.当我们把文本域里面的值赋值给li的时候，多添加一个删除的链接。
2.需要把所有的链接获取过来，当我们点击当前的链接的时候，删除当前链接所在的li。
3.阻止链接跳转需要添加javascript:void(0);或者javascript:;。

```html
<style>
	* {
		margin: 0;
		padding: 0;
	}

	body {
		padding: 100px;
	}

	textarea {
		width: 200px;
		height: 100px;
		border: 1px solid pink;
		outline: none;
		resize: none;
	}

	ul {
		margin-top: 50px;
	}

	li {
		width: 300px;
		padding: 5px;
		background-color: rgb(245, 209, 243);
		color: red;
		font-size: 14px;
		margin: 15px 0;
	}

	li a {
		float: right;
	}
</style>

<body>
	<textarea name="" id=""></textarea>
	<button>发布</button>
	<ul>

	</ul>
	<script>
		// 1. 获取元素
		var btn = document.querySelector('button');
		var text = document.querySelector('textarea');
		var ul = document.querySelector('ul');
		// 2. 注册事件
		btn.onclick = function () {
			if (text.value == '') {
				alert('您没有输入内容');
				return false;
			} else {
				// console.log(text.value);
				// (1) 创建元素
				var li = document.createElement('li');
				// 先有li 才能赋值
				li.innerHTML = text.value + "<a href='javascript:;'>删除</a>";
				// (2) 添加元素
				// ul.appendChild(li);
				ul.insertBefore(li, ul.children[0]);
				// (3) 删除元素 删除的是当前链接的li  它的父亲
				var as = document.querySelectorAll('a');
				for (var i = 0; i < as.length; i++) {
					as[i].onclick = function () {
						// node.removeChild(child); 删除的是 li 当前a所在的li  this.parentNode;
						ul.removeChild(this.parentNode);
					}
				}
			}
		}
	</script>
</body>
```

##### 5.6复制节点(克隆节点)

```javascript
node.cloneNode() 
```

node.cloneNode()方法返回调用该方法的节点的一个副本。也称为克隆节点/拷贝节点。

```html
<body>
	<ul>
		<li>1111</li>
		<li>2</li>
		<li>3</li>
	</ul>
	<script>
		var ul = document.querySelector('ul');
		// 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容
		// 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容
		var lili = ul.children[0].cloneNode(true);
		ul.appendChild(lili);
	</script>
</body>
```

注意：
1.如果括号参数为空或者为 false，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。
2.如果括号参数为 true，则是深度拷贝，会复制节点本身以及里面所有的子节点。

###### 案例：动态生成表格

|  姓名  |    科目    | 成绩 | 操作 |
| :----: | :--------: | :--: | :--: |
| 魏璎珞 | JavaScript | 100  | 删除 |
|  弘历  | JavaScript |  90  | 删除 |
|  傅恒  | JavaScript |  99  | 删除 |
|  明玉  | JavaScript |  89  | 删除 |

###### 案例分析

1.因为里面的学生数据都是动态的，我们需要js 动态生成。这里我们模拟数据，自己定义好数据。数据我们采取对象形式存储。
2.所有的数据都是放到tbody里面的行里面。
3.因为行很多，我们需要循环创建多个行(对应多少人)
4.每个行里面又有很多单元格(对应里面的数据)，我们还继续使用循环创建多个单元格，
并且把数据存入里面(双重for循环)
5.最后—列单元格是删除，需要单独创建单元格。
6.最后添加删除操作，单击删除，可以删除当前行。

```html
<style>
	table {
		width: 500px;
		margin: 100px auto;
		border-collapse: collapse;
		text-align: center;
	}

	td,
	th {
		border: 1px solid #333;
	}

	thead tr {
		height: 40px;
		background-color: #ccc;
	}
</style>

<body>
	<table cellspacing="0">
		<thead>
			<tr>
				<th>姓名</th>
				<th>科目</th>
				<th>成绩</th>
				<th>操作</th>
			</tr>
		</thead>
		<tbody>

		</tbody>
	</table>
	<script>
		// 1.先去准备好学生的数据
		var datas = [{
		    name: '魏璎珞',
		    subject: 'JavaScript',
		    score: 100
		}, {
		    name: '弘历',
		    subject: 'JavaScript',
		    score: 98
		}, {
		    name: '傅恒',
		    subject: 'JavaScript',
		    score: 99
		}, {
		    name: '明玉',
		    subject: 'JavaScript',
		    score: 88
		}, {
		    name: '大猪蹄子',
		    subject: 'JavaScript',
		    score: 0
		}];
		// 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行
		var tbody = document.querySelector('tbody');
		for (var i = 0; i < datas.length; i++) { // 外面的for循环管行 tr
			// 1. 创建 tr行
			var tr = document.createElement('tr');
			tbody.appendChild(tr);
			// 2. 行里面创建单元格(跟数据有关系的3个单元格) td 单元格的数量取决于每个对象里面的属性个数  for循环遍历对象 datas[i]
			for (var k in datas[i]) { // 里面的for循环管列 td
				// 创建单元格 
				var td = document.createElement('td');
				// 把对象里面的属性值 datas[i][k] 给 td  
				// console.log(datas[i][k]);
				td.innerHTML = datas[i][k];
				tr.appendChild(td);
			}
			// 3. 创建有删除2个字的单元格 
			var td = document.createElement('td');
			td.innerHTML = '<a href="javascript:;">删除 </a>';
			tr.appendChild(td);
		}
		// 4. 删除操作 开始 
		var as = document.querySelectorAll('a');
		for (var i = 0; i < as.length; i++) {
			as[i].onclick = function () {
				// 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)  
				tbody.removeChild(this.parentNode.parentNode)
			}
		}
		// for(var k in obj) {
		//     k 得到的是属性名
		//     obj[k] 得到是属性值
		// }
	</script>
</body>
```

##### 5.8三种动态创建元素区别(了解)

1.`document.write() `
2.`element.innerHTML `
3.`document.createElement()`

区别：
1.document.write是直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘。
2.innerHTML是将内容写入某个 DOM节点，不会导致页面全部重绘。
3.innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂。
4.createElement()创建多个元素效率稍低一点点，但是结构更清晰。

总结：
不同浏览器下， innerHTML效率要比 creatElement高。

#### 6.DOM重点核心

文档对象模型（Document Object Model，简称 DOM），是 W3C组织推荐的处理可扩展标记语言（HTML或者XML）的标准编程接口。
W3C已经定义了一系列的 DOM接口，通过这些 DOM接口可以改变网页的内容、结构和样式。

1.对于JavaScript，为了能够使JavaScript操作HTML，JavaScript就有了一套自己的dom编程接口。
2.对于HTML，dom使得html形成一棵dom树。包含文档、元素、节点。


我们获取过来的DOM元素是一个对象（object），所以称为文档对象模型


关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。 

##### 6.1创建

1.document.write 
2.innerHTML 
3.createElement

##### 6.2增

1.appendChild 
2.insertBefore

##### 6.3删

1.removeChild

##### 6.4改

主要修改dom的元素属性，dom元素的内容、属性，表单的值等。

1.修改元素属性：src、href、title等 
2.修改普通元素内容：innerHTML、innerText 
3.修改表单元素：value、type、disabled等 
4.修改元素样式：style、className

##### 6.5查

主要获取查询dom的元素

1.DOM提供的API方法：getElementById、getElementsByTagName  古老用法不太推荐 
2.H5提供的新方法：querySelector、querySelectorAll  提倡 
3.利用节点操作获取元素：父(parentNode)、子(children)、兄(previousElementSibling、nextElementSibling)  提倡

##### 6.6属性操作

主要针对于自定义属性。

1.setAttribute：设置dom的属性值
2.getAttribute：得到dom的属性值
3.removeAttribute移除属性

##### 6.7事件操作

给元素注册事件，采取 事件源.事件类型 = 事件处理程序

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左健触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

## 事件高级

#### 1.注册事件(绑定事件)

##### 1.1注册事件概述

给元素添加事件，称为注册事件或者绑定事件。

注册事件有两种方式：传统方式和方法监听注册方式。

###### 传统注册方式

1.利用 on开头的事件 onclick 。
2.`<button onclick=“alert('hi~')”></button>` 。
3.`btn.onclick = function() {}`。
4.特点：注册事件的唯一性。
5.同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数 。

###### 方法监听注册方式

1.w3c标准推荐方式。
2.addEventListener()它是一个方法 。
3.IE9之前的 IE不支持此方法，可使用 attachEvent()代替。
4.特点：同一个元素同一个事件可以注册多个监听器。
5.按注册顺序依次执行。

##### 1.2 addEventListener事件监听方式

```javascript
eventTarget.addEventListener(type, listener[, useCapture]) 
```

eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。

该方法接收三个参数：
type：事件类型字符串，比如 click、mouseover，注意这里不要带 on。
listener：事件处理函数，事件发生时，会调用该监听函数。
useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM事件流后，我们再进一步学习。

##### 1.3 attachEvent事件监听方式

```javascript
eventTarget.attachEvent(eventNameWithOn, callback) 
```

eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。

该方法接收两个参数： 
eventNameWithOn：事件类型字符串，比如 onclick、onmouseover，这里要带 on
callback：事件处理函数，当目标触发事件时回调函数被调用。

注意：IE8及早期版本支持

```html
<body>
	<button>传统注册事件</button>
	<button>方法监听注册事件</button>
	<button>ie9 attachEvent</button>
	<script>
		var btns = document.querySelectorAll('button');
		// 1. 传统方式注册事件
		btns[0].onclick = function () {
			alert('hi');
		}
		btns[0].onclick = function () {
			alert('hao a u');
		}
		// 2. 事件侦听注册事件 addEventListener 
		// (1) 里面的事件类型是字符串 必定加引号 而且不带on
		// (2) 同一个元素 同一个事件可以添加多个侦听器（事件处理程序）
		btns[1].addEventListener('click', function () {
			alert(22);
		})
		btns[1].addEventListener('click', function () {
			alert(33);
		})
		// 3. attachEvent ie9以前的版本支持
		btns[2].attachEvent('onclick', function () {
			alert(11);
		})
	</script>
</body>
```

##### 1.4注册事件兼容性解决方案 

```javascript
function addEventListener(element, eventName, fn) {
	//判断当前浏览器是否支持 addEventListener方法 
	if (element.addEventListener) {
		element.addEventListener(eventName, fn);
		//第三个参数默认是 false	
	} else if (element.attachEvent) {
		element.attachEvent('on' + eventName, fn);
	} else {
		//相当于 element.onclick = fn;
		element['on' + eventName] = fn;
	}
}
```

兼容性处理的原则：首先照顾大多数浏览器，再处理特殊浏览器。

#### 2.删除事件(解绑事件)

##### 2.1删除事件的方式

###### 1.传统注册方式

```javascript
eventTarget.onclick = null; 
```

###### 2.方法监听注册方式 

```javascript
eventTarget.removeEventListener(type, listener[, useCapture]);
eventTarget.detachEvent(eventNameWithOn, callback); 
```

```html
<body>
	<div style="width:100px;height:100px;background-color: pink;">1</div>
	<div style="width:100px;height:100px;background-color: pink">2</div>
	<div style="width:100px;height:100px;background-color: pink;">3</div>
	<script>
		var divs = document.querySelectorAll('div');
		// 1. 传统方式删除事件
		divs[0].onclick = function () {
			alert(11);
			divs[0].onclick = null;
		}

		// 2. removeEventListener 删除事件
		divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号
		function fn() {
			alert(22);
			divs[1].removeEventListener('click', fn);
		}

		// 3. detachEvent
		divs[2].attachEvent('onclick', fn1);
		function fn1() {
			alert(33);
			divs[2].detachEvent('onclick', fn1);
		}
	</script>
</body>
```

##### 2.2删除事件兼容性解决方案

```javascript
function removeEventListener(element, eventName, fn) {
	//判断当前浏览器是否支持 removeEventListener方法
	if (element.removeEventListener) {
		element.removeEventListener(eventName, fn); //第三个参数默认是 false 
	} else if (element.detachEvent) {
		element.detachEvent('on' + eventName, fn);
	} else {
		element['on' + eventName] = null;
	}
}
```

#### 3.DOM事件流

事件流描述的是从页面中接收事件的顺序。

事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM事件流。

比如我们给一个 div注册了点击事件： 
DOM事件流分为3个阶段：
1.捕获阶段
2.当前目标阶段
3.冒泡阶段

![image-20211001063132584](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211001063132584.png)

事件冒泡：IE最早提出，事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM最顶层节点的过程。 
事件捕获：网景最早提出，由 DOM最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。

我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。

![image-20211001063256045](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211001063256045.png)

事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM事件流。

```html
<style>
	.father {
		overflow: hidden;
		width: 300px;
		height: 300px;
		margin: 100px auto;
		background-color: pink;
		text-align: center;
	}

	.son {
		width: 200px;
		height: 200px;
		margin: 50px;
		background-color: purple;
		line-height: 200px;
		color: #fff;
	}
</style>

<body>
	<div class="father">
		<div class="son">son盒子</div>
	</div>
	<script>
		// dom 事件流 三个阶段
		// 1. JS 代码中只能执行捕获或者冒泡其中的一个阶段。
		// 2. onclick 和 attachEvent（ie） 只能得到冒泡阶段。
		// 3. 捕获阶段 如果addEventListener 第三个参数是 true 那么则处于捕获阶段  document -> html -> body -> father -> son
		var son = document.querySelector('.son');
		son.addEventListener('click', function () {
			alert('son');
		}, true);
		var father = document.querySelector('.father');
		father.addEventListener('click', function () {
			alert('father');
		}, true);
		// 4. 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略 那么则处于冒泡阶段  son -> father ->body -> html -> document
		var son = document.querySelector('.son');
		son.addEventListener('click', function () {
			alert('son');
		}, false);
		var father = document.querySelector('.father');
		father.addEventListener('click', function () {
			alert('father');
		}, false);
		document.addEventListener('click', function () {
			alert('document');
		})
	</script>
</body>
```

注意：
1.JS代码中只能执行捕获或者冒泡其中的一个阶段。 
2.onclick和 attachEvent只能得到冒泡阶段。 
3.addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是 false），表示在事件冒泡阶段调用事件处理程序。 
4.实际开发中我们很少使用事件捕获，我们更关注事件冒泡。
5.有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave。
6.事件冒泡有时候会带来麻烦，有时候又会帮助很巧妙的做某些事件，我们后面讲解。

#### 4.事件对象

##### 4.1什么是事件对象 

```javascript
eventTarget.onclick = function (event) { }
eventTarget.addEventListener('click', function (event) { })
//这个 event就是事件对象，我们还喜欢的写成 e 或者 evt
```

官方解释： event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。

简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。

比如：
1.谁绑定了这个事件。
2.鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
3.键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。

##### 4.2事件对象的使用语法

```javascript
eventTarget.onclick = function (event) {
	//这个 event就是事件对象，我们还喜欢的写成 e或者 evt}
	eventTarget.addEventListener('click', function (event) {
		//这个 event就是事件对象，我们还喜欢的写成 e或者 evt
	})
}
```

这个 event是个形参，系统帮我们设定为事件对象，不需要传递实参过去。
当我们注册事件时， event对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。

##### 4.3事件对象的兼容性方案

事件对象本身的获取存在兼容问题：
1.标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e就可以获取到。
2.在 IE6~8中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event中获取查找。

解决: 

```javascript
e = e || window.event;
```

##### 4.4事件对象的常见属性和方法

e.target和 this的区别：
this是事件绑定的元素，这个函数的调用者（绑定这个事件的元素）
e.target是事件触发的元素。

| 事件对象属性方法    | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| e.target            | 返回触发事件的对象   标准                                    |
| e.srcElement        | 返回触发事件的对象   非标准ie6-8使用                         |
| e.type              | 返回事件的类型比如click mouseover不带on                      |
| e.cancelBubble      | 该属性阻止冒泡非标准 ie6-8使用                               |
| e.returnValue       | 该属性阻止默认事件（默认行为)   非标准ie6-8使用比如不让链接跳转 |
| e.preventDefault()  | 该方法阻止默认事件（默认行为)   标准比如不让链接跳转         |
| e.stopPropagation() | 阻止冒泡标准                                                 |

```html
<body>
    <div>123</div>
    <a href="http://www.baidu.com">百度</a>
    <form action="http://www.baidu.com">
        <input type="submit" value="提交" name="sub">
    </form>
    <script>
        // 常见事件对象的属性和方法
        // 1. 返回事件类型
        var div = document.querySelector('div');
        div.addEventListener('click', fn);
        div.addEventListener('mouseover', fn);
        div.addEventListener('mouseout', fn);
        function fn(e) {
            console.log(e.type);
        }
        // 2. 阻止默认行为（事件） 让链接不跳转 或者让提交按钮不提交
        var a = document.querySelector('a');
        a.addEventListener('click', function (e) {
            e.preventDefault(); //  dom 标准写法
        })
        // 3. 传统的注册方式
        a.onclick = function (e) {
            // 普通浏览器 e.preventDefault();  方法
            e.preventDefault();
            // 低版本浏览器 ie678  returnValue  属性
            e.returnValue;
            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题
            // 特点：return后面的代码不执行了，而且只限于传统的注册方式
            return false;
            alert(11);
        }
    </script>
</body>
```

#### 5.阻止事件冒泡

##### 5.1阻止事件冒泡的两种方式

事件冒泡：开始时由最具体的元素接收，然后逐级向上传播到到 DOM最顶层节点。

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

###### 阻止事件冒泡 

标准写法：利用事件对象里面的 stopPropagation()方法

```javascript
e.stopPropagation()
```

 非标准写法：IE 6-8利用事件对象 cancelBubble属性

```javascript
e.cancelBubble = true; 
```

```html
<style>
    .father {
        overflow: hidden;
        width: 300px;
        height: 300px;
        margin: 100px auto;
        background-color: pink;
        text-align: center;
    }

    .son {
        width: 200px;
        height: 200px;
        margin: 50px;
        background-color: purple;
        line-height: 200px;
        color: #fff;
    }
</style>

<body>
    <div class="father">
        <div class="son">son儿子</div>
    </div>
    <script>
        // 常见事件对象的属性和方法
        // 阻止冒泡  dom 推荐的标准 stopPropagation() 
        var son = document.querySelector('.son');
        son.addEventListener('click', function (e) {
            alert('son');
            e.stopPropagation(); // stop 停止  Propagation 传播
            e.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡
        }, false);

        var father = document.querySelector('.father');
        father.addEventListener('click', function () {
            alert('father');
        }, false);
        document.addEventListener('click', function () {
            alert('document');
        })
    </script>
</body>
```

##### 5.2阻止事件冒泡的兼容性解决方案

```javascript
if (e && e.stopPropagation) {
	e.stopPropagation();
} else {
	window.event.cancelBubble = true;
}
```

#### 6.事件委托(代理、委派)

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。

生活中有如下场景：
咱们班有 100个学生，快递员有 100个快递，如果一个个的送花费时间较长。同时每个学生领取的时候，也需要排队领取，也花费时间较长，何如？

解决方案：快递员把 100个快递，委托给班主任，班主任把这些快递放到办公室，同学们下课自行领取即可。

优势：快递员省事，委托给班主任就可以走了。同学们领取也方便，因为相信班主任。

事件冒泡本身的特性，会带来的坏处，也会带来的好处，需要我们灵活掌握。程序中也有如此场景： 

```html
<ul>
	<li>知否知否，应该有弹框在手</li>
	<li>知否知否，应该有弹框在手</li>
	<li>知否知否，应该有弹框在手</li>
	<li>知否知否，应该有弹框在手</li>
	<li>知否知否，应该有弹框在手</li>
</ul>
```

点击每个 li都会弹出对话框，以前需要给每个 li注册事件，是非常辛苦的，而且访问DOM的次数越多，这就会延长整个页面的交互就绪时间。

##### 事件委托

事件委托也称为事件代理，在 jQuery里面称为事件委派。

##### 事件委托的原理

不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。
以上案例：给 ul注册点击事件，然后利用事件对象的 target来找到当前点击的 li，因为点击 li，事件会冒泡到 ul上， ul有注册事件，就会触发事件监听器。

##### 事件委托的作用

我们只操作了一次DOM，提高了程序的性能。

```html
<body>
	<ul>
		<li>知否知否，点我应有弹框在手！</li>
		<li>知否知否，点我应有弹框在手！</li>
		<li>知否知否，点我应有弹框在手！</li>
		<li>知否知否，点我应有弹框在手！</li>
		<li>知否知否，点我应有弹框在手！</li>
	</ul>
	<script>
		// 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点
		var ul = document.querySelector('ul');
		ul.addEventListener('click', function (e) {
			// alert('知否知否，点我应有弹框在手！');
			// e.target 这个可以得到我们点击的对象
			e.target.style.backgroundColor = 'pink';
		})
	</script>
</body>
```

#### 7.常用的鼠标事件

##### 7.1常用的鼠标事件

| 鼠标事件    | 触发条件         |
| ----------- | ---------------- |
| onclick     | 鼠标点击左键触发 |
| onmouseover | 鼠标经过触发     |
| onmouseout  | 鼠标离开触发     |
| onfocus     | 获得鼠标焦点触发 |
| onblur      | 失去鼠标焦点触发 |
| onmousemove | 鼠标移动触发     |
| onmouseup   | 鼠标弹起触发     |
| onmousedown | 鼠标按下触发     |

```javascript
// 鼠标按下和弹起
document.onmousedown = function () {
	console.log('我按下了');
}
document.onmouseup = function () {
	console.log('我弹起了');
}
```

###### 1.禁止鼠标右键菜单contextmenu

**contextmenu**主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```javascript
document.addEventListener('contextmenu', function (e) {
	e.preventDefault();
})
```

###### 2.禁止鼠标选中(selectstart开始选中) 

```javascript
document.addEventListener('selectstart', function (e) {
    e.preventDefault();
})
```

##### 7.2鼠标事件对象

event对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要是用鼠标事件对象MouseEvent和键盘事件对象KeyboardEvent。

| 鼠标事件对象 | 说明                                     |
| ------------ | ---------------------------------------- |
| e.clientX    | 返回鼠标相对于浏览器窗口可视区的X坐标    |
| e.clientY    | 返回鼠标相对于浏览器窗口可视区的Y坐标    |
| e.pageX      | 返回鼠标相对于文档页面的X坐标   IE9+支持 |
| e.pageY      | 返回鼠标相对于文档页面的Y坐标   IE9+支持 |
| e.screenX    | 返回鼠标相对于电脑屏幕的X坐标            |
| e.screenY    | 返回鼠标相对于电脑屏幕的Y坐标            |

```html
<body style="height:3000px">
	<script>
		// 鼠标事件对象 MouseEvent
		document.addEventListener('click', function (e) {
			// 1. client 鼠标在可视区的x和y坐标
			console.log(e.clientX);
			console.log(e.clientY);
			console.log('---------------------');

			// 2. page 鼠标在页面文档的x和y坐标
			console.log(e.pageX);
			console.log(e.pageY);
			console.log('---------------------');

			// 3. screen 鼠标在电脑屏幕的x和y坐标
			console.log(e.screenX);
			console.log(e.screenY);

		})
	</script>
</body>
```

###### 案例：跟随鼠标的天使

这个天使图片一直跟随鼠标移动

###### 案例分析

1.鼠标不断的移动，使用鼠标移动事件： mousemove。
2.在页面中移动，给document注册事件。
3.图片要移动距离，而且不占位置，我们使用绝对定位即可。
4.核心原理：每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值就可以移动图片。

###### 实现代码

```html
<body>
	<img src="#" alt="" style="position: absolute;">
	<script>
		var pic = document.querySelector('img');
		document.addEventListener('mousemove', function (e) {
			var x = e.pageX;
			var y = e.pageY;
			pic.style.top = y - 40 + 'px';
			pic.style.left = x - 50 + 'px';
		})
	</script>
</body>
```

#### 8.常用的键盘事件

##### 8.1常用键盘事件

事件除了使用鼠标触发，还可以使用键盘触发。

| 键盘事件   | 触发条件                                                     |
| ---------- | ------------------------------------------------------------ |
| onkeyup    | 某个键盘按键被松开时触发                                     |
| onkeydown  | 某个键盘按键被按下时触发                                     |
| onkeypress | 某个键盘按键被按下时触发   但是它不识别功能键比如ctrl shift箭头等 |

```html
<script>
	// 常用的键盘事件
	//1. keyup 按键弹起的时候触发 
	document.onkeyup = function () {
		console.log('我弹起了');
	}
	document.addEventListener('keyup', function () {
		console.log('我弹起了');
	})
	//2. keydown 按键按下的时候触发，能识别功能键，比如 ctrl shift 左右箭头啊
	document.addEventListener('keydown', function () {
		console.log('我按下了down');
	})
	//3. keypress 按键按下的时候触发，不能识别功能键 比如 ctrl shift 左右箭头啊
	document.addEventListener('keypress', function () {
		console.log('我按下了press');
	})
	// 4. 三个事件的执行顺序  keydown-- keypress-- keyup
</script>
```

注意：
1.如果使用addEventListener不需要加on。
2.onkeypress和前面2个的区别是，它不识别功能键，比如左右箭头，shift等。 
3.三个事件的执行顺序是： keydown ---keypress ---keyup。

##### 8.2键盘事件对象

| 键盘事件对象属性 | 说明              |
| ---------------- | ----------------- |
| keyCode          | 返回该键的ASCIl值 |

注意：onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写。

在我们实际开发中，我们更多的使用keydown和keyup，它能识别所有的键（包括功能键）Keypress不识别功能键，但是keyCode属性能区分大小写，返回不同的ASCII值

```javascript
// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值
// 1. 我们的keyup 和keydown事件不区分字母大小写  a 和 A 得到的都是65
// 2. 我们的keypress 事件 区分字母大小写  a  97 和 A 得到的是65
document.addEventListener('keyup', function (e) {
	// console.log(e);
	console.log('up:' + e.keyCode);
	// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键
	if (e.keyCode === 65) {
	    alert('您按下的a键');
	} else {
	    alert('您没有按下a键')
	}
})
document.addEventListener('keypress', function (e) {
	// console.log(e);
	console.log('press:' + e.keyCode);
})
```

##### 8.3 ASCII表

![](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\0.jpg)

###### 案例：模拟京东按键输入内容

当我们按下 s键，光标就定位到搜索框

###### 案例分析

1.核心思路：检测用户是否按下了s键，如果按下s键，就把光标定位到搜索框里面。
2.使用键盘事件对象里面的keyCode判断用户按下的是否是s键。
3.搜索框获得焦点：使用 js里面的 focus()方法。

###### 实现代码 

```html
<body>
	<input type="text">
	<script>
		var search = document.querySelector('input');
		document.addEventListener('keyup', function (e) {
			// console.log(e.keyCode);
			if (e.keyCode === 83) {
				search.focus();
			}
		})
	</script>
</body>
```

###### 案例：模拟京东快递单号查询

要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。

###### 案例分析

1.快递单号输入内容时，上面的大号字体盒子(con)显示(这里面的文字。
2.同时把快递单号里面的值(value)获取过来赋值给 con盒子(innerText)做为内容。
3.如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子。
4.注意： keydown和 keypress在文本框里面的特点：他们两个事件触发的时候，文字还没有落入文本框中。
5.keyup事件触发的时候，文字已经落入文本框里面了。
6.当我们失去焦点，就隐藏这个 con盒子。
7.当我们获得焦点，并且文本框内容不为空，就显示这个 con盒子。

```html
<style>
	* {
	    margin: 0;
	    padding: 0;
	}

	.search {
	    position: relative;
	    width: 178px;
	    margin: 100px;
	}

	.con {
	    display: none;
	    position: absolute;
	    top: -40px;
	    width: 171px;
	    border: 1px solid rgba(0, 0, 0, .2);
	    box-shadow: 0 2px 4px rgba(0, 0, 0, .2);
	    padding: 5px 0;
	    font-size: 18px;
	    line-height: 20px;
	    color: #333;
	}

	.con::before {  /* 小三角 */
	    content: '';
	    width: 0;
	    height: 0;
	    position: absolute;
	    top: 28px;
	    left: 18px;
	    border: 8px solid #000;
	    border-style: solid dashed dashed;
	    border-color: #fff transparent transparent;
	}
</style>

<body>
    <div class="search">
        <div class="con">123</div>
        <input type="text" placeholder="请输入您的快递单号" class="jd">
    </div>
    <script>
        // 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的字号更大）
        // 表单检测用户输入： 给表单添加键盘事件
        // 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容
        // 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子
        var con = document.querySelector('.con');
        var jd_input = document.querySelector('.jd');
        jd_input.addEventListener('keyup', function () {
            // console.log('输入内容啦');
            if (this.value == '') {
                con.style.display = 'none';
            } else {
                con.style.display = 'block';
                con.innerText = this.value;
            }
        })
        // 当我们失去焦点，就隐藏这个con盒子
        jd_input.addEventListener('blur', function () {
            con.style.display = 'none';
        })
        // 当我们获得焦点，就显示这个con盒子
        jd_input.addEventListener('focus', function () {
            if (this.value !== '') {
                con.style.display = 'block';
            }
        })
    </script>
</body>
```

## BOM浏览器对象模型

#### 1.BOM概述 

##### 1.1什么是 BOM

BOM(Browser Object Model)即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。

BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。

BOM缺乏标准，JavaScript语法的标准化组织是ECMA，DOM的标准化组织是 W3C，BOM最初是Netscape浏览器标准的一部分。

###### DOM

文档对象模型(Document Object Model)
DOM就是把「文档」当做一个「对象」来看待
DOM的顶级对象是 document
DOM主要学习的是操作页面元素
DOM是 W3C标准规范

###### BOM 

浏览器对象模型(Browser Object Model)
把「浏览器」当做一个「对象」来看待
BOM的顶级对象是 window
BOM学习的是浏览器窗口交互的一些对象
BOM是浏览器厂商在各自浏览器上定义的，兼容性较差

##### 1.2 BOM的构成

BOM比DOM更大，它包含DOM。

![image-20211001134517203](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20211001134517203.png)

window对象是浏览器的顶级对象，它具有双重角色。 

1.它是JS访问浏览器窗口的一个接口。
2.它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。

在调用的时候可以省略window，前面学习的对话框都属于window对象方法，如 alert()、prompt()等。

```html
<body>
	<script>
		// window.document.querySelector()
		var num = 10;
		console.log(num);
		console.log(window.num);

		function fn() {
		    console.log(11);

		}
		fn();
		window.fn();
		// alert(11);
		// window.alert(11)
		console.dir(window);
		// var name = 10;
		console.log(window.name);
	</script>
</body>
```

注意：window下的一个特殊属性window.name。

#### 2.window对象的常见事件

##### 2.1窗口加载事件 

```
window.onload = function () { }
// 或者
window.addEventListener("load", function () { });
```

window.onload是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS文件等),就调用的处理函数。

注意：
1.有了window.onload就可以把 JS代码写到页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。
2.window.onload传统注册事件方式只能写一次，如果有多个，会以最后一个window.onload为准。
3.如果使用addEventListener则没有限制

```
document.addEventListener('DOMContentLoaded',function(){})
```

DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。Ie9以上才支持

如果页面的图片很多的话,从用户访问到onload触发可能需要较长的时间,交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded事件比较合适。

```
// window.onload = function() {
//     var btn = document.querySelector('button');
//     btn.addEventListener('click', function() {
//         alert('点击我');
//     })
// }
// window.onload = function() {
//     alert(22);
// }
window.addEventListener('load', function() {
    var btn = document.querySelector('button');
    btn.addEventListener('click', function() {
        alert('点击我');
    })
})
window.addEventListener('load', function() {

    alert(22);
})
document.addEventListener('DOMContentLoaded', function() {
        alert(33);
    })
    // load 等页面内容全部加载完毕，包含页面dom元素 图片 flash  css 等等
    // DOMContentLoaded 是DOM 加载完毕，不包含图片 falsh css 等就可以执行 加载速度比 load更快一些
```

##### 2.2调整窗口大小事件 

```
window.onresize = function(){} window.addEventListener("resize",function(){}); 
```

window.onresize是调整窗口大小加载事件,当触发时就调用的处理函数。

注意：
1.只要窗口大小发生像素变化，就会触发这个事件。
2.我们经常利用这个事件完成响应式布局。 window.innerWidth当前屏幕的宽度

```
<body>
	<script>
		window.addEventListener('load', function() {
			var div = document.querySelector('div');
			window.addEventListener('resize', function() {
				console.log(window.innerWidth);
				console.log('变化了');
				if (window.innerWidth <= 800) {
					div.style.display = 'none';
				} else {
					div.style.display = 'block';
				}
			})
		})
	</script>
	<div></div>
</body>
```

#### 3.定时器

##### 3.1两种定时器

window对象给我们提供了 2个非常好用的方法-定时器。 
- setTimeout() 
- setInterval()

##### 3.2 setTimeout()定时器

```
window.setTimeout(调用函数,[延迟的毫秒数]);
```

setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。

注意：
1.window可以省略。
2.这个调用函数可以直接写函数，或者写函数名或者采取字符串 ‘函数名()'三种形式。第三种不推荐
3.延迟的毫秒数省略默认是 0，如果写，必须是毫秒。
4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。

setTimeout()这个调用函数我们也称为回调函数 callback

普通函数是按照代码顺序直接调用。而这个函数，需要等待时间，时间到了才去调用这个函数，因此称为回调函数。简单理解：回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。
以前我们讲的 element.onclick = function(){}或者 element.addEventListener(“click”, fn);里面的函数也是回调函数。

```
// 1. setTimeout 
// 语法规范：  window.setTimeout(调用函数, 延时时间);
// 1. 这个window在调用的时候可以省略
// 2. 这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0
// 3. 这个调用函数可以直接写函数 还可以写 函数名 还有一个写法 '函数名()'
// 4. 页面中可能有很多的定时器，我们经常给定时器加标识符 （名字)
// setTimeout(function() {
//     console.log('时间到了');

// }, 2000);

function callback() {
    console.log('爆炸了');
}
var timer1 = setTimeout(callback, 3000);
var timer2 = setTimeout(callback, 5000);
// setTimeout('callback()', 3000); // 我们不提倡这个写法
```

###### 案例： 5秒后自动关闭的广告

###### 案例分析

1.核心思路：5秒之后，就把这个广告隐藏起来
2.用定时器setTimeout

```
<body>
	<img src="images/ad.jpg" alt="" class="ad">
	<script>
		var ad = document.querySelector('.ad');
		setTimeout(function() {
			ad.style.display = 'none';
		}, 5000);
	</script>
</body>
```

##### 3.3停止setTimeout()定时器

```
window.clearTimeout(timeoutID)
```

clearTimeout()方法取消了先前通过调用 setTimeout()建立的定时器。

注意：
1.window可以省略。
2.里面的参数就是定时器的标识符。

```
<body>
	<button>点击停止定时器</button>
	<script>
		var btn = document.querySelector('button');
		var timer = setTimeout(function() {
			console.log('爆炸了');
		}, 5000);
		btn.addEventListener('click', function() {
			clearTimeout(timer);
		})
	</script>
</body>
```

##### 3.4 setInterval()定时器

```
window.setInterval(回调函数,[间隔的毫秒数]);
```

setInterval()方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。

注意：
1.window可以省略。
2.这个调用函数可以直接写函数，或者写函数名或者采取字符串'函数名()'三种形式。
3.间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。
4.因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。
5.第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。

```
// 1. setInterval 
// 语法规范：  window.setInterval(调用函数, 延时时间);
setInterval(function() {
    console.log('继续输出');
}, 1000);
// 2. setTimeout  延时时间到了，就去调用这个回调函数，只调用一次，就结束了这个定时器
// 3. setInterval  每隔这个延时时间，就去调用这个回调函数，会调用很多次，重复调用这个函数
```

###### 案例：倒计时

###### 案例分析

①这个倒计时是不断变化的，因此需要定时器来自动变化（setInterval）
②三个黑色盒子里面分别存放时分秒
③三个黑色盒子利用innerHTML放入计算的小时分钟秒数 
④第一次执行也是间隔毫秒数，因此刚刷新页面会有空白
⑤最好采取封装函数的方式，这样可以先调用一次这个函数，防止刚开始刷新页面有空白问题

```
<style>
    div {
        margin: 200px;
    }

    span {
        display: inline-block;
        width: 40px;
        height: 40px;
        background-color: #333;
        font-size: 20px;
        color: #fff;
        text-align: center;
        line-height: 40px;
    }
</style>

<body>
    <div>
        <span class="hour">1</span>
        <span class="minute">2</span>
        <span class="second">3</span>
    </div>
    <script>
        // 1. 获取元素 
        var hour = document.querySelector('.hour'); // 小时的黑色盒子
        var minute = document.querySelector('.minute'); // 分钟的黑色盒子
        var second = document.querySelector('.second'); // 秒数的黑色盒子
        var inputTime = +new Date('2022-6-1 18:00:00'); // 返回的是用户输入时间总的毫秒数
        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白 
        // 2. 开启定时器
        setInterval(countDown, 1000);

        function countDown() {
            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数
            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数 
            var h = parseInt(times / 60 / 60 % 24); //时
            h = h < 10 ? '0' + h : h;
            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子
            var m = parseInt(times / 60 % 60); // 分
            m = m < 10 ? '0' + m : m;
            minute.innerHTML = m;
            var s = parseInt(times % 60); // 当前的秒
            s = s < 10 ? '0' + s : s;
            second.innerHTML = s;
        }
    </script>
</body>
```

##### 3.5停止 setInterval()定时器

```
window.clearInterval(intervalID); 
```

clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。

注意：
1.window可以省略。
2.里面的参数就是定时器的标识符。

```
<body>
	<button class="begin">开启定时器</button>
	<button class="stop">停止定时器</button>
	<script>
		var begin = document.querySelector('.begin');
		var stop = document.querySelector('.stop');
		var timer = null; // 全局变量  null是一个空对象
		begin.addEventListener('click', function () {
			timer = setInterval(function () {
				console.log('ni hao ma');

			}, 1000);
		})
		stop.addEventListener('click', function () {
			clearInterval(timer);
		})
	</script>
</body>
```

###### 案例：发送短信

点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信

###### 案例分析

①按钮点击之后，会禁用 disabled为true
②同时按钮里面的内容会变化，注意 button里面的内容通过 innerHTML修改
③里面秒数是有变化的，因此需要用到定时器
④定义一个变量，在定时器里面，不断递减
⑤如果变量为0说明到了时间，我们需要停止定时器，并且复原按钮初始状态。

```
<body>
	手机号码： <input type="number"> <button>发送</button>
	<script>
		// 按钮点击之后，会禁用 disabled 为true 
		// 同时按钮里面的内容会变化， 注意 button 里面的内容通过 innerHTML修改
		// 里面秒数是有变化的，因此需要用到定时器
		// 定义一个变量，在定时器里面，不断递减
		// 如果变量为0 说明到了时间，我们需要停止定时器，并且复原按钮初始状态
		var btn = document.querySelector('button');
		var time = 3; // 定义剩下的秒数
		btn.addEventListener('click', function() {
			btn.disabled = true;
			var timer = setInterval(function() {
				if (time == 0) {
					// 清除定时器和复原按钮
					clearInterval(timer);
					btn.disabled = false;
					btn.innerHTML = '发送';
				} else {
					btn.innerHTML = '还剩下' + time + '秒';
					time--;
				}
			}, 1000);
		})
	</script>
</body>
```

##### 3.6 this

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。

现阶段，我们先了解一下几个this指向：
1.全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)。
2.方法调用中谁调用this指向谁。
3.构造函数中this指向构造函数的实例。

###### 课后作业：时钟

课后同学们做一个电子时钟，显示当前的年月日，时分秒，要求自动变化

#### 4.JS执行机制

##### 4.1 JS是单线程

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为 Javascript这门脚本语言诞生的使命所致 ——JavaScript是为处理页面中用户的交互，以及操作 DOM而诞生的。比如我们对某个 DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

###### 一个问题

以下代码执行的结果是什么？

```
console.log(1);
setTimeout(function () {
	console.log(3);
}, 1000);
console.log(2);
```

那么以下代码执行的结果又是什么？

```
console.log(1);
setTimeout(function () {
	console.log(3);
}, 0);
console.log(2);
```

##### 4.2同步和异步

为了解决这个问题，利用多核 CPU的计算能力，HTML5提出 Web Worker标准，允许 JavaScript脚本创建多个线程。于是，JS中出现了同步和异步。

###### 同步

前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的、同步的。比如做饭的同步做法：我们要烧水煮饭，等水开了（10分钟之后），再去切菜，炒菜。

###### 异步

你在做一件事情时，因为这件事情会花费很长时间，在做这件事的同时，你还可以去处理其他事情。比如做饭的异步做法，我们在烧水的同时，利用这10分钟，去切菜，炒菜。

他们的本质区别：这条流水线上各个流程的执行顺序不同。

##### 4.3同步和异步

###### 同步任务

同步任务都在主线程上执行，形成一个执行栈。

###### 异步任务

JS的异步是通过回调函数实现的。

一般而言，异步任务有以下三种类型：
1.普通事件，如click、resize等
2.资源加载，如load、error等
3.定时器，包括setInterval、setTimeout等

异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。 

##### 4.4 JS执行机制

1.先执行执行栈中的同步任务。
2.异步任务（回调函数）放入任务队列中。
3.一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。

```
console.log(1);
document.onclick = function () {
	console.log('click');
}
console.log(2);
setTimeout(function () {
	console.log(3)
}, 3000)
```

由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环(event loop)。

#### 5.location对象

##### 5.1什么是 location对象

window对象给我们提供了一个location属性用于获取或设置窗体的 URL，并且可以用于解析 URL。因为这个属性返回的是一个对象，所以我们将这个属性也称为location对象。

##### 5.2 URL 

统一资源定位符 (Uniform Resource Locator, URL)是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。

URL的一般语法格式为： 

```
protocol://host[:port]/path/[?cuery]#fragment
http://www.itcast.cn/index.html?name=andy&age=18#link
```

| 组成     | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| protocol | 通信协议   常用的http,ftp,maito等                            |
| host     | 主机(域名)   www.itheima.com                                 |
| port     | 端口号   可选，省略时使用方案的默认端口如http的默认端口为80  |
| path     | 路径由零或多个/符号隔开的字符串，一般用来表示主机上的一个目录或文件地址 |
| query    | 参数   以键值对的形式,通过&符号分隔开来                      |
| fragment | 片段   #后面内容常见于链接锚点                               |

##### 5.3 location对象的属性

| location对象属性  | 返回值                             |
| ----------------- | ---------------------------------- |
| location.href     | 获取或者设置整个URL                |
| location.host     | 返回主机   (域名)www.itheima.com   |
| location.port     | 返回端口号   如果未写返回空字符串  |
| location.pathname | 返回路径                           |
| location.search   | 返回参数                           |
| location.hash     | 返回片段   #后面内容常见于链接锚点 |

重点记住：href 和search

###### 案例： 5秒钟之后自动跳转页面

###### 案例分析

1.利用定时器做倒计时效果
2.时间到了，就跳转页面。使用 location.href

```
<body>
    <button>点击</button>
    <div></div>
    <script>
        var btn = document.querySelector('button');
        var div = document.querySelector('div');
        btn.addEventListener('click', function () {
            // console.log(location.href);
            location.href = 'http://www.itcast.cn';
        })
        var timer = 5;
        countDown();
        setInterval(countDown, 1000);
        function countDown() {
            if (timer == 0) {
                location.href = 'http://www.itcast.cn';
            } else {
                div.innerHTML = '您将在' + timer + '秒钟之后跳转到首页';
                timer--;
            }

        }
    </script>
</body>
```

###### 案例：获取 URL参数数据

主要练习数据在不同页面中的传递。

###### 案例分析

1.第一个登录页面，里面有提交表单， action提交到 index.html页面
2.第二个页面，可以使用第一个页面的参数，这样实现了一个数据不同页面之间的传递效果
3.第二个页面之所以可以使用第一个页面的数据，是利用了URL里面的location.search参数
4.在第二个页面中，需要把这个参数提取。
5.第一步去掉？利用 substr
6.第二步利用=号分割键和值 split(‘=‘)
7.第一个数组就是键第二个数组就是值

```

```

##### 5.4 location对象的方法

| location对象方法   | 返回值                                                       |
| :----------------- | ------------------------------------------------------------ |
| location.assign()  | 跟href—样，可以跳转页面(也称为重定向页面)                    |
| location.replace() | 替换当前页面，因为不记录历史，所以不能后退页面               |
| location.reload()  | 重新加载页面，相当于刷新按钮或者f5如果参数为true强制刷新ctrl+f5 |

```
<script>
	var btn = document.querySelector('button');
	btn.addEventListener('click', function () {
		// 记录浏览历史，所以可以实现后退功能
		// location.assign('http://www.itcast.cn');
		// 不记录浏览历史，所以不可以实现后退功能
		// location.replace('http://www.itcast.cn');
		location.reload(true);
	})
</script>
```

#### 6.navigator对象

navigator对象包含有关浏览器的信息，它有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的 user-agent头部的值。

下面前端代码可以判断用户那个终端打开页面，实现跳转 

```
<script>
	if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
		window.location.href = "";  // 手机
	} else {
		window.location.href = "";  // 电脑
	}
</script>
```

#### 7.history对象

window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。

| history对象方法 | 作用                                                  |
| --------------- | ----------------------------------------------------- |
| back()          | 可以后退功能                                          |
| forward()       | 前进功能                                              |
| go(参数)        | 前进后退功能参数如果是1前进1个页面如果是-1后退1个页面 |


history对象一般在实际开发中比较少用，但是会在一些 OA办公系统中见到。

```
<script>
	var btn = document.querySelector('button');
	btn.addEventListener('click', function () {
		// history.forward();
		// history.go(1);
		history.back();
		history.go(-1);
	})
</script>
```

## PC端网页特效

#### 1.元素偏移量 offset系列 

##### 1.1 offset概述

offset翻译过来就是偏移量，我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。

获得元素距离带有定位父元素的位置。
获得元素自身的大小（宽度高度）。
注意：返回的数值都不带单位

offset系列常用属性：

| offset系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.offsetParent | 返回作为该元素带有定位的父级元素如果父级都没有定位则返回body |
| element.offsetTop    | 返回元素相对带有定位父元素上方的偏移                         |
| element.offsetLeft   | 返回元素相对带有定位父元素左边框的偏移                       |
| element.offsetwidth  | 返回自身包括padding、边框、内容区的宽度,返回数值不带单位     |
| element.offsetHeight | 返回自身包括padding、边框、内容区的高度，返回数值不带单位    |

```
<body>
	<script>
		// offset 系列
		var father = document.querySelector('.father');
		var son = document.querySelector('.son');
		// 1.可以得到元素的偏移 位置 返回的不带单位的数值  
		console.log(father.offsetTop);
		console.log(father.offsetLeft);
		// 它以带有定位的父亲为准  如果么有父亲或者父亲没有定位 则以 body 为准
		console.log(son.offsetLeft);
		var w = document.querySelector('.w');
		// 2.可以得到元素的大小 宽度和高度 是包含padding + border + width 
		console.log(w.offsetWidth);
		console.log(w.offsetHeight);
		// 3. 返回带有定位的父亲 否则返回的是body
		console.log(son.offsetParent); // 返回带有定位的父亲 否则返回的是body
		console.log(son.parentNode); // 返回父亲 是最近一级的父亲 亲爸爸 不管父亲有没有定位
	</script>
</body>
```

##### 1.2 offset与style区别 

###### offset

- offset可以得到任意样式表中的样式值。
- offset系列获得的数值是没有单位的。
- offsetWidth包含padding+border+width。
- offsetWidth等属性是只读属性，只能获取不能赋值。
- 所以，我们想要获取元素大小位置，用offset更合适 。

###### style 

- style只能得到行内样式表中的样式值。
- style.width获得的是带有单位的字符串。
- style.width获得不包含padding和border的值。
- style.width是可读写属性，可以获取也可以赋值。
- 所以，我们想要给元素更改值，则需要用style改变。

###### 案例：获取鼠标在盒子的坐标

###### 案例分析

1.我们在盒子内点击，想要得到鼠标距离盒子左右的距离。
2.首先得到鼠标在页面中的坐标(e.pageX, e.pageY)。
3.其次得到盒子在页面中的距离(box.offsetLeft, box.offsetTop)。
4.用鼠标距离页面的坐标减去盒子在页面中的距离，得到鼠标在盒子内的坐标。
5.如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动事件mousemove。

```
<body>
	<div class="box" style="width: 200px;height: 200px;background-color: #eee;"></div>
	<script>
		var box = document.querySelector('.box ');
		box.addEventListener('mousemove', function (e) {
			var x = e.pageX - this.offsetLeft;
			var y = e.pageY - this.offsetTop;
			this.innerHTML = 'x坐标是' + x + 'y坐标是' + y;
		})
	</script>
</body>
```

###### 案例：拖动模态框(略)---p292-p294

###### 案例：仿京东放大镜效果(略)---p295-p299

#### 2.元素可视区client系列 

client翻译过来就是客户端，我们使用 client系列的相关属性来获取元素可视区的相关信息。通过 client系列的相关属性可以动态的得到该元素的边框大小、元素大小等。

| client系列属性       | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| element.clientTop    | 返回元素上边框的大小                                         |
| element.clientLeft   | 返回元素左边框的大小                                         |
| element.clientWidth  | 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 |
| element.clientHeight | 返回自身包括padding、内容区的高度，不含边框，返回数值不带单位 |

```
<body>
	<div></div>
	<script>
		// client 宽度 和我们offsetWidth 最大的区别就是 不包含边框
		var div = document.querySelector('div');
		console.log(div.clientWidth);
	</script>
</body>
```

###### 案例：淘宝flexible.js源码分析(略)---p301-p303

#### 3.元素滚动 scroll系列 

##### 3.1元素scroll系列属性


scroll翻译过来就是滚动的，我们使用 scroll系列的相关属性可以动态的得到该元素的大小、滚动距离等。

| scroll系列属性       | 作用                                           |
| -------------------- | ---------------------------------------------- |
| element.scrollTop    | 返回被卷去的上侧距离，返回数值不带单位         |
| element.scrollLeft   | 返回被卷去的左侧距离，返回数值不带单位         |
| element.scrollWidth  | 返回自身实际的宽度，不含边框，返回数值不带单位 |
| element.scrollHeight | 返回自身实际的高度，不含边框，返回数值不带单位 |

##### 3.2页面被卷去的头部

如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。

```
<body>
    <script>
        // scroll 系列
        var div = document.querySelector('div');
        console.log(div.scrollHeight);
        console.log(div.clientHeight);
        // scroll滚动事件当我们滚动条发生变化会触发的事件
        div.addEventListener('scroll', function() {
            console.log(div.scrollTop);
        })
    </script>
</body>
```

###### 案例：仿淘宝固定右侧侧边栏(略)---p305-p306

##### 3.3页面被卷去的头部兼容性解决方案 

需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：
1.声明了DTD，使用 document.documentElement.scrollTop
2.未声明DTD，使用 document.body.scrollTop
3.新方法window.pageYOffset和 window.pageXOffset，IE9开始支持

```
function getScroll() {
	return {
		left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0,
		top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
	};
}
// 使用的时候 getScroll().left
```

##### 3.4三大系列总结

| 三大系列大小对比    | 作用                                                         |
| ------------------- | ------------------------------------------------------------ |
| element.offsetWidth | 返回自身包括padding 、边框、内容区的宽度，返回数值不带单位   |
| element.clientWidth | 返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位 |
| element.scrollWidth | 返回自身实际的宽度，不含边框,返回数值不带单位                |

他们主要用法： 
1.offset系列经常用于获得元素位置 offsetLeft offsetTop
2.client经常用于获取元素大小 clientWidth clientHeight
3.scroll经常用于获取滚动距离 scrollTop scrollLeft 
4.注意页面滚动的距离通过 window.pageXOffset获得

##### 3.5mouseenter和mouseover的区别 

###### mouseenter鼠标事件

- 当鼠标移动到元素上时就会触发 mouseenter事件。
- 类似 mouseover，它们两者之间的差别是。
- mouseover鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter只会经过自身盒子触发。
- 之所以这样，就是因为mouseenter**不会冒泡**。
- 跟mouseenter搭配鼠标离开 mouseleave同样不会冒泡。

#### 4.动画函数封装

##### 4.1动画实现原理

核心原理：通过定时器 setInterval()不断移动盒子位置。

实现步骤：
1.获得盒子当前位置
2.让盒子在当前位置加上1个移动距离
3.利用定时器不断重复这个操作
4.加一个结束定时器的条件 
5.注意此元素***需要添加定位***，才能使用element.style.left 

```
<style>
	div {
		position: absolute;
		left: 0;
		width: 100px;
		height: 100px;
		background-color: pink;
	}
</style>

<body>
	<div></div>
	<script>
		// 动画原理
		// 1. 获得盒子当前位置  
		// 2. 让盒子在当前位置加上1个移动距离
		// 3. 利用定时器不断重复这个操作
		// 4. 加一个结束定时器的条件
		// 5. 注意此元素需要添加定位， 才能使用element.style.left
		var div = document.querySelector('div');
		var timer = setInterval(function () {
			if (div.offsetLeft >= 400) {
				// 停止动画 本质是停止定时器
				clearInterval(timer);
			}
			div.style.left = div.offsetLeft + 1 + 'px';
		}, 30);
	</script>
</body>
```

##### 4.2动画函数简单封装

注意函数需要传递2个参数，动画对象和移动到的距离。

```
<style>
	div {
	    position: absolute;
	    left: 0;
	    width: 100px;
	    height: 100px;
	    background-color: pink;
	}
	
	span {
	    position: absolute;
	    left: 0;
	    top: 200px;
	    display: block;
	    width: 150px;
	    height: 150px;
	    background-color: purple;
	}
</style>

<body>
	<div></div>
	<span>夏雨荷</span>
	<script>
		// 简单动画函数封装obj目标对象,target目标位置
		function animate(obj, target) {
			var timer = setInterval(function() {
			    if (obj.offsetLeft >= target) {
			        // 停止动画 本质是停止定时器
			        clearInterval(timer);
			    }
			    obj.style.left = obj.offsetLeft + 1 + 'px';
			}, 30);
		}

		var div = document.querySelector('div');
		var span = document.querySelector('span');
		// 调用函数
		animate(div, 300);
		animate(span, 200);
	</script>
</body>
```

##### 4.3动画函数给不同元素记录不同定时器

如果多个元素都使用这个动画函数，每次都要 var声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。

核心原理：利用 JS是一门动态语言，可以很方便的给当前对象添加属性。

```
<style>
    div {
        position: absolute;
        left: 0;
        width: 100px;
        height: 100px;
        background-color: pink;
    }

    span {
        position: absolute;
        left: 0;
        top: 200px;
        display: block;
        width: 150px;
        height: 150px;
        background-color: purple;
    }
</style>

<body>
    <button>点击夏雨荷才走</button>
    <div></div>
    <span>夏雨荷</span>
    <script>
        // var obj = {};
        // obj.name = 'andy';
        // 简单动画函数封装obj目标对象 target 目标位置
        // 给不同的元素指定了不同的定时器
        function animate(obj, target) {
            // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
            // 解决方案就是 让我们元素只有一个定时器执行
            // 先清除以前的定时器，只保留当前的一个定时器执行
            clearInterval(obj.timer);
            obj.timer = setInterval(function () {
                if (obj.offsetLeft >= target) {
                    // 停止动画 本质是停止定时器
                    clearInterval(obj.timer);
                }
                obj.style.left = obj.offsetLeft + 1 + 'px';
            }, 30);
        }

        var div = document.querySelector('div');
        var span = document.querySelector('span');
        var btn = document.querySelector('button');
        // 调用函数
        animate(div, 300);
        btn.addEventListener('click', function () {
            animate(span, 200);
        })
    </script>
</body>
```

##### 4.4缓动效果原理

缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来。

思路：
1.让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。 
2.核心算法：(目标值-现在的位置) / 10做为每次移动的距离步长。
3.停止的条件是：让当前盒子位置等于目标位置就停止定时器。
4.注意步长值需要取整。

##### 4.5动画函数多个目标值之间移动

可以让动画函数从800移动到500。

当我们点击按钮时候，判断步长是正值还是负值
1.如果是正值，则步长往大了取整。
2.如果是负值，则步长向小了取整。

##### 4.6动画函数添加回调函数

回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。

回调函数写的位置：定时器结束的位置。

##### 4.7动画函数封装到单独JS文件里面

因为以后经常使用这个动画函数，可以单独封装到一个JS文件里面，使用的时候引用这个JS文件即可。 

1.单独新建一个JS文件。 
2.HTML文件引入JS文件。

#### 5.常见网页特效案例

###### 案例：网页轮播图---p317-p327

轮播图也称为焦点图，是网页中比较常见的网页特效。

功能需求： 
1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。
2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。
3.图片播放的同时，下面小圆圈模块跟随一起变化。
4.点击小圆圈，可以播放相应图片。
5.鼠标不经过轮播图，轮播图也会自动播放图片。
6.鼠标经过，轮播图模块，自动播放停止。

###### 案例分析1

① 因为 js较多，我们单独新建 js文件夹，再新建 js文件，引入页面中。
② 此时需要添加 load事件。
③ 鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。
④显示隐藏 display按钮。

###### 案例分析2

①动态生成小圆圈 
②核心思路：小圆圈的个数要跟图片张数一致 
③所以首先先得到 ul里面图片的张数（图片放入 li里面，所以就是 li的个数） 
④利用循环动态生成小圆圈（这个小圆圈要放入 ol里面） 
⑤创建节点 createElement(‘li’) 
⑥插入节点 ol. appendChild(li) 
⑦第一个小圆圈需要添加 current类

###### 案例分析3 

① 小圆圈的排他思想
② 点击当前小圆圈，就添加 current类
③ 其余的小圆圈就移除这个 current类
④ 注意：我们在刚才生成小圆圈的同时，就可以直接绑定这个点击事件了。

###### 案例分析4

①点击小圆圈滚动图片
②此时用到 animate动画函数，将 js文件引入（注意，因为 index.js依赖 animate.js所以， animate.js要写到 index.js上面）
③使用动画函数的前提，该元素必须有定位
④注意是 ul移动而不是小 li
⑤滚动图片的核心算法：点击某个小圆圈，就让图片滚动小圆圈的索引号乘以图片的宽度做为 ul移动距离
⑥此时需要知道小圆圈的索引号，我们可以在生成小圆圈的时候，给它设置一个自定义属性，点击的时候获取这个自定义属性即可。

###### 案例分析5 

①点击右侧按钮一次，就让图片滚动一张。
②声明一个变量 num，点击一次，自增 1，让这个变量乘以图片宽度，就是 ul的滚动距离。
③图片无缝滚动原理
④把ul第一个 li复制一份，放到 ul的最后面 
⑤当图片滚动到克隆的最后一张图片时，让 ul快速的、不做动画的跳到最左侧： left为0
⑥同时 num赋值为 0，可以从新开始滚动图片了

###### 案例分析6

① 克隆第一张图片
② 克隆 ul第一个 li cloneNode()加true深克隆复制里面的子节点  false浅克隆
③ 添加到 ul最后面 appendChild

###### 案例分析7

①点击右侧按钮，小圆圈跟随变化
②最简单的做法是再声明一个变量 circle，每次点击自增 1，注意，左侧按钮也需要这个变量，因此要声明全局变量。
③但是图片有 5张，我们小圆圈只有 4个少一个，必须加一个判断条件
④如果 circle == 4就从新复原为 0

###### 案例分析8

①自动播放功能
②添加一个定时器
③自动播放轮播图，实际就类似于点击了右侧按钮
④此时我们使用手动调用右侧按钮点击事件 arrow_r.click()
⑤鼠标经过 focus就停止定时器
⑥鼠标离开 focus就开启定时

##### 5.1节流阀

防止轮播图按钮连续点击造成播放过快。

节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。

核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。

开始设置一个变量 

```
var flag = true; 
If(flag) {flag = false; do something}关闭水龙头
利用回调函数动画执行完毕， flag = true打开水龙头
```

###### 案例：返回顶部

滚动窗口至文档中的特定位置。 
window.scroll(x, y)
注意，里面的x和y不跟单位，直接写数字

###### 案例分析

①带有动画的返回顶部
②此时可以继续使用我们封装的动画函数
③只需要把所有的left相关的值改为跟页面垂直滚动距离相关就可以了
④页面滚动了多少，可以通过 window.pageYOffset得到
⑤最后是页面滚动，使用 window.scroll(x,y)

###### 案例：筋头云案例

鼠标经过某个小li，筋斗云跟这到当前小li位置鼠标离开这个小li，筋斗云复原为原来的位置鼠标点击了某个小li，筋斗云就会留在点击这个小li的位置

###### 案例分析

①利用动画函数做动画效果
②原先筋斗云的起始位置是0
③鼠标经过某个小li，把当前小li的 offsetLeft位置做为目标值即可
④鼠标离开某个小li，就把目标值设为 0
⑤如果点击了某个小li，就把li当前的位置存储起来，做为筋斗云的起始位置

## 移动端网页特效

#### 1.触屏事件

##### 1.1触屏事件概述

移动端浏览器兼容性较好，我们不需要考虑以前 JS的兼容性问题，可以放心的使用原生 JS书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS都有。

touch对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。

常见的触屏事件如下：

| 触屏touch事件 | 说明                          |
| ------------- | ----------------------------- |
| touchstart    | 手指触摸到一个DOM元素时触发   |
| touchmove     | 手指在一个DOM元素上滑动时触发 |
| touchend      | 手指从一个DOM元素上移开时触发 |

```
<body>
	<div style="width:100px;height:100px;background-color:pink;"></div>
	<script>
		// 1. 获取元素
		var div = document.querySelector('div');
		// 2. 手指触摸DOM元素事件
		div.addEventListener('touchstart', function () {
			console.log('我摸了你');
		});
		// 3. 手指在DOM元素身上移动事件
		div.addEventListener('touchmove', function () {
			console.log('我继续摸');
		});
		// 4. 手指离开DOM元素事件
		div.addEventListener('touchend', function () {
			console.log('轻轻的我走了');
		});
	</script>
</body>
```

##### 1.2触摸事件对象（TouchEvent）

TouchEvent是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等。

touchstart、touchmove、touchend三个事件都会各自有事件对象。

触摸事件对象重点我们看三个常见对象列表：

| 触摸列表       | 说明                                             |
| -------------- | ------------------------------------------------ |
| touches        | 正在触摸屏幕的所有手指的一个列表                 |
| targetTouches  | 正在触摸当前DOM元素上的手指的一个列表            |
| changedTouches | 手指状态发生了改变的列表，从无到有，从有到无变化 |

因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes。

##### 1.3移动端拖动元素

1.touchstart、touchmove、touchend可以实现拖动元素。
2.但是拖动元素需要当前手指的坐标值我们可以使用 targetTouches[0]里面的pageX和 pageY。
3.移动端拖动的原理：手指移动中，计算出手指移动的距离。然后用盒子原来的位置 +手指移动的距离。
4.手指移动的距离：手指滑动中的位置减去手指刚开始触摸的位置。

拖动元素三步曲：
1.触摸元素 touchstart：获取手指初始坐标，同时获得盒子原来的位置
2.移动手指 touchmove：计算手指的滑动距离，并且移动盒子
3.离开手指 touchend：


注意：手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动e.preventDefault();

```
<style>
	div {
		position: absolute;
		left: 0;
		width: 100px;
		height: 100px;
		background-color: pink;
	}
</style>

<body>
	<div></div>
	<script>
		// （1） 触摸元素 touchstart:获取手指初始坐标，同时获得盒子原来的位置
		// （2） 移动手指 touchmove:计算手指的滑动距离，并且移动盒子
		// （3） 离开手指 touchend:
		var div = document.querySelector('div');
		var startX = 0; //获取手指初始坐标
		var startY = 0;
		var x = 0; //获得盒子原来的位置
		var y = 0;
		div.addEventListener('touchstart', function (e) {
			//  获取手指初始坐标
			startX = e.targetTouches[0].pageX;
			startY = e.targetTouches[0].pageY;
			x = this.offsetLeft;
			y = this.offsetTop;
		});
		div.addEventListener('touchmove', function (e) {
			//  计算手指的移动距离： 手指移动之后的坐标减去手指初始的坐标
			var moveX = e.targetTouches[0].pageX - startX;
			var moveY = e.targetTouches[0].pageY - startY;
			// 移动我们的盒子 盒子原来的位置 + 手指移动的距离
			this.style.left = x + moveX + 'px';
			this.style.top = y + moveY + 'px';
			e.preventDefault(); // 阻止屏幕滚动的默认行为
		});
	</script>
</body>
```

#### 2.移动端常见特效---p335-p350

###### 案例：移动端轮播图

移动端轮播图功能和基本PC端一致。 
1.可以自动播放图片
2.手指可以拖动播放轮播图

###### 案例分析1

①自动播放功能
②开启定时器
③移动端移动，可以使用translate移动
④想要图片优雅的移动，请添加过渡效果

###### 案例分析2

①自动播放功能-无缝滚动
②注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断
③此时需要添加检测过渡完成事件 transitionend
④判断条件：如果索引号等于 3说明走到最后一张图片，此时索引号要复原为 0
⑤此时图片，去掉过渡效果，然后移动
⑥如果索引号小于0，说明是倒着走，索引号等于2
⑦此时图片，去掉过渡效果，然后移动

##### 2.1 classList属性

classList属性是HTML5新增的一个属性，返回元素的类名。但是ie10以上版本支持。该属性用于在元素中添加，移除及切换 CSS类。

有以下方法：

添加类：
element.classList.add（ ’类名 ’）； 

```
focus.classList.add('current');
```

移除类：
element.classList.remove（ ’类名 ’）;

```
focus.classList.remove('current');
```

切换类：
element.classList.toggle（ ’类名 ’）；

```
focus.classList.toggle('current');
```

注意以上方法里面，所有类名都不带点。

###### 案例分析

1.小圆点跟随变化效果
2.把ol里面li带有current类名的选出来去掉类名 remove
3.让当前索引号的小li加上 current add
4.但是，是等着过渡结束之后变化，所以这个写到 transitionend事件里面

###### 案例分析

1.手指滑动轮播图
2.本质就是ul跟随手指移动，简单说就是移动端拖动元素
3.触摸元素 touchstart： 获取手指初始坐标
4.移动手指 touchmove： 计算手指的滑动距离，并且移动盒子
5.离开手指 touchend:根据滑动的距离分不同的情况
6.如果移动距离小于某个像素就回弹原来位置
7.如果移动距离大于某个像素就上一张下一张滑动。
8.滑动也分为左滑动和右滑动判断的标准是移动距离正负如果是负值就是左滑反之右滑
9.如果是左滑就播放下一张(index++)
10.如果是右滑就播放上一张(index--)

###### 案例：返回顶部

当页面滚动某个地方，就显示，否则隐藏点击可以返回顶部

###### 案例分析

1.滚动某个地方显示
2.事件：scroll页面滚动事件
3.如果被卷去的头部（window.pageYOffset）大于某个数值
4.点击， window.scroll(0,0)返回顶部

##### 2.2 click延时解决方案

移动端 click事件会有 300ms的延时，原因是移动端屏幕双击会缩放(double tap to zoom)页面。

解决方案：

1.禁用缩放。浏览器禁用默认的双击缩放行为并且去掉 300ms的点击延迟。

```
<meta name="viewport" content="user-scalable=no">
```

2.利用touch事件自己封装这个事件解决 300ms延迟。

原理就是：
1.当我们手指触摸屏幕，记录当前触摸时间
2.当我们手指离开屏幕，用离开的时间减去触摸的时间
3.如果时间小于150ms，并且没有滑动过屏幕，那么我们就定义为点击

```
// 封装 tap，解决 click 300ms延时 
function tap(obj, callback) {
	var isMove = false;
	var startTime = 0; //记录触摸时候的时间变量
	obj.addEventListener('touchstart', function (e) {
		startTime = Date.now(); //记录触摸时间 
	});
	obj.addEventListener('touchmove', function (e) {
		isMove = true; //看看是否有滑动，有滑动算拖拽，不算点击 
	});
	obj.addEventListener('touchend', function (e) {
		if (!isMove && (Date.now() - startTime) < 150) { //如果手指触摸和离开时间小于 150ms算点击 
			callback && callback(); //执行回调函数 
		}
		isMove = false; //取反重置 startTime = 0; 
		startTime = 0;
	});
}
//调用 
tap(div, function () { //执行代码 });
```

移动端 click事件会有 300ms的延时，原因是移动端屏幕双击会缩放(double tap to zoom)页面。

解决方案：
3.使用插件。 fastclick插件解决 300ms延迟。

#### 3.移动端常用开发插件

##### 3.1什么是插件

移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？

JS插件是 js文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。

特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。我们以前写的animate.js也算一个最简单的插件

fastclick插件解决 300ms延迟。使用延时
GitHub官网地址： https://github.com/ftlabs/fastclick 

##### 3.2插件的使用 

1.引入 js插件文件。
2.按照规定语法使用。

fastclick插件解决 300ms延迟。使用延时
GitHub官网地址： https://github.com/ftlabs/fastclick 

```
if ('addEventListener' in document) {
	document.addEventListener('DOMContentLoaded', function () {
		FastClick.attach(document.body);
	}, false);
}
```

##### 3.3 Swiper插件的使用

中文官网地址： https://www.swiper.com.cn/

1.引入插件相关文件。
2.按照规定语法使用

##### 3.4其他移动端常见插件

superslide：http://www.superslide2.com/ 
iscroll：https://github.com/cubiq/iscroll

##### 3.5插件的使用总结

1.确认插件实现的功能
2.去官网查看使用说明
3.下载插件 
4.打开demo实例文件，查看需要引入的相关文件，并且引入 
5.复制demo实例文件中的结构html，样式css以及js代码

##### 3.6练习-移动端视频插件 zy.media.js

H5给我们提供了 video标签，但是浏览器的支持情况不同。

不同的视频格式文件，我们可以通过source解决。
但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。
这个时候我们可以使用插件方式来制作。 

#### 4.移动端常用开发框架

##### 4.1框架概述

框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。

插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。

前端常用的框架有**Bootstrap**、**Vue**、**Angular**、**React**等。既能开发PC端，也能开发移动端前端常用的移动端插件有**swiper**、**superslide**、**iscroll**等。

框架：大而全，一整套解决方案
插件：小而专一，某个功能的解决方案

##### 4.2 Bootstrap

Bootstrap是一个简洁、直观、强悍的前端开发框架，它让 web开发更迅速、简单。
它能开发PC端，也能开发移动端。

Bootstrap JS插件使用步骤： 
1.引入相关js文件
2.复制HTML结构
3.修改对应样式 
4.修改相应JS参数 


## 本地存储

#### 1.本地存储

随着互联网的快速发展，基于网页的应用越来越普遍，同时也变的越来越复杂，为了满足各种各样的需求，会经常性在本地存储大量的数据，HTML5规范提出了相关解决方案。

##### 本地存储特性

1.数据存储在用户浏览器中。
2.设置、读取方便、甚至页面刷新不丢失数据。
3.容量较大，sessionStorage约5M、localStorage约20M。
4.只能存储字符串，可以将对象JSON.stringify()编码后存储。

#### 2.window.sessionStorage

1.生命周期为关闭浏览器窗口。
2.在同一个窗口(页面)下数据可以共享。
3.以键值对的形式存储使用。

存储数据： 

```
sessionStorage.setItem(key, value)
```

获取数据： 

```
sessionStorage.getItem(key)
```

删除数据： 

```
sessionStorage.removeItem(key)
```

删除所有数据：

```
sessionStorage.clear()
```

#### 3.window.localStorage

1.声明周期永久生效，除非手动删除否则关闭页面也会存在。
2.可以多窗口（页面）共享（同一浏览器可以共享） 。
3.以键值对的形式存储使用 。

存储数据： 

```
localStorage.setItem(key, value)
```

获取数据： 

```
localStorage.getItem(key)
```

删除数据： 

```
localStorage.removeItem(key)
```

删除所有数据：

```
localStorage.clear()
```

#### 4.移动端常见特效

###### 案例：记住用户名

如果勾选记住用户名，下次用户打开浏览器，就在文本框里面自动显示上次登录的用户名

###### 案例分析

1.把数据存起来，用到本地存储。
2.关闭页面，也可以显示用户名，所以用到localStorage。
3.打开页面，先判断是否有这个用户名，如果有，就在表单里面显示用户名，并且勾选复选框。
4.当复选框发生改变的时候 change事件⑤如果勾选，就存储，否则就移除。

